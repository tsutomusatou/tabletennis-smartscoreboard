{"version":3,"sources":["../src/obniz/libs/ComponentAbstact.ts"],"names":[],"mappings":"AAAA;;;GAGG;;AAEH,OAAO,YAAY,MAAM,eAAe,CAAC;AACzC,OAAO,KAAK,MAAM,UAAU,CAAC;AAC7B,OAAO,EAAE,UAAU,EAAwC,MAAM,eAAe,CAAC;AAEjF,OAAO,QAAQ,MAAM,sBAAsB,CAAC;AAE5C,oBAAY,YAAY,GAAG,CAAC,GAAG,IAAI,EAAE,GAAG,KAAK,GAAG,CAAC;AAEjD,MAAM,WAAW,kBAAkB;IACjC;;;OAGG;IACH,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB;;OAEG;IACH,KAAK,CAAC,EAAE,OAAO,CAAC;IAChB,MAAM,CAAC,EAAE;QAAE,CAAC,MAAM,EAAE,MAAM,GAAG,OAAO,UAAU,CAAA;KAAE,CAAC;CAClD;AAED,8BAAsB,iBAAiB,CAAC,UAAU,SAAS,MAAM,GAAG,MAAM,CAAE,SAAQ,YAAY,CAAC,UAAU,CAAC;IAC1G;;OAEG;IACI,KAAK,EAAE,KAAK,CAAC;IAEpB;;OAEG;IACI,OAAO,EAAE,MAAM,CAAa;IAEnC,SAAS,CAAC,kBAAkB,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,YAAY,EAAE,CAAA;KAAE,CAAM;gBAEzD,KAAK,EAAE,KAAK;IAKjB,eAAe,CAAC,IAAI,EAAE,GAAG;IA2BzB,QAAQ,CAAC,UAAU,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,QAAQ,CAAC,WAAW;aAKjD,cAAc,IAAI,MAAM,GAAG,IAAI;IAE/C,SAAS,CAAC,QAAQ,CAAC,MAAM,IAAI,IAAI;IAEjC,SAAS,CAAC,SAAS,CAAC,SAAS,EAAE,MAAM,EAAE,IAAI,EAAE,YAAY;cAOzC,sBAAsB,CAAC,OAAO,EAAE,GAAG,EAAE,UAAU,EAAE,MAAM,EAAE,MAAM,CAAC,EAAE,kBAAkB,GAAG,OAAO,CAAC,GAAG,CAAC;IAKnH,SAAS,CAAC,eAAe,CAAC,UAAU,EAAE,MAAM,EAAE,MAAM,CAAC,EAAE,kBAAkB,GAAG,OAAO,CAAC,GAAG,CAAC;CA2DzF","file":"ComponentAbstact.d.ts","sourcesContent":["/**\n * @packageDocumentation\n * @module ObnizCore.Components\n */\n\nimport EventEmitter from \"eventemitter3\";\nimport Obniz from \"../index\";\nimport { ObnizError, ObnizOfflineError, ObnizTimeoutError } from \"../ObnizError\";\n\nimport WSSchema from \"./wscommand/WSSchema\";\n\nexport type EventHandler = (...args: any) => any;\n\nexport interface ReceiveJsonOptions {\n  /**\n   * Indicate timeout in milliseconds.\n   * If not appliced, default timeout will be applied.\n   */\n  timeout?: number;\n\n  /**\n   * Indicate sequencial operation or not\n   */\n  queue?: boolean;\n  errors?: { [schema: string]: typeof ObnizError };\n}\n\nexport abstract class ComponentAbstract<EventTypes extends string = string> extends EventEmitter<EventTypes> {\n  /**\n   * obniz to be used\n   */\n  public Obniz: Obniz;\n\n  /**\n   * Rsponse waiting timeout in milliseconds\n   */\n  public timeout: number = 30 * 1000;\n\n  protected _eventHandlerQueue: { [key: string]: EventHandler[] } = {};\n\n  constructor(obniz: Obniz) {\n    super();\n    this.Obniz = obniz;\n  }\n\n  public notifyFromObniz(json: any) {\n    for (const eventName of this.eventNames()) {\n      if (typeof eventName !== \"string\" || !eventName.startsWith(\"/response/\")) {\n        continue;\n      }\n      const errors = this.validate(eventName, json);\n      if (errors.valid) {\n        this.emit(eventName, json);\n      }\n    }\n    for (const eventName in this._eventHandlerQueue) {\n      if (typeof eventName !== \"string\" || !eventName.startsWith(\"/response/\")) {\n        continue;\n      }\n      if (this._eventHandlerQueue[eventName].length === 0) {\n        continue;\n      }\n      const errors = this.validate(eventName, json);\n      if (errors.valid) {\n        const func = this._eventHandlerQueue[eventName].shift();\n        if (func) {\n          func(json);\n        }\n      }\n    }\n  }\n\n  public validate(commandUri: any, json: any): WSSchema.MultiResult {\n    const schema = WSSchema.getSchema(commandUri);\n    return WSSchema.validateMultiple(json, schema);\n  }\n\n  public abstract schemaBasePath(): string | null;\n\n  protected abstract _reset(): void;\n\n  protected onceQueue(eventName: string, func: EventHandler) {\n    this._eventHandlerQueue[eventName] = this._eventHandlerQueue[eventName] || [];\n    if (typeof func === \"function\") {\n      this._eventHandlerQueue[eventName].push(func);\n    }\n  }\n\n  protected async sendAndReceiveJsonWait(sendObj: any, schemaPath: string, option?: ReceiveJsonOptions): Promise<any> {\n    this.Obniz.send(sendObj);\n    return await this.receiveJsonWait(schemaPath, option);\n  }\n\n  protected receiveJsonWait(schemaPath: string, option?: ReceiveJsonOptions): Promise<any> {\n    option = option || {};\n    option.timeout = option.timeout || this.timeout;\n    option.queue = option.queue !== false;\n    option.errors = option.errors || {};\n\n    return new Promise((resolve, reject) => {\n      if (this.Obniz.connectionState !== \"connected\") {\n        reject(new ObnizOfflineError());\n        return;\n      }\n      const clearListeners = () => {\n        this.Obniz.off(\"close\", onObnizClosed);\n        this.off(schemaPath as any, onDataReceived);\n        if (typeof timeoutHandler === \"number\") {\n          clearTimeout(timeoutHandler);\n          timeoutHandler = undefined;\n        }\n        for (const one of onErrorFuncs) {\n          this.off(one.path, one.onError);\n        }\n      };\n      const onObnizClosed = () => {\n        clearListeners();\n        const error = new ObnizOfflineError();\n        reject(error);\n      };\n      const onDataReceived = (schemaData: any) => {\n        clearListeners();\n\n        resolve(schemaData);\n      };\n      const onTimeout = () => {\n        clearListeners();\n\n        const error = new ObnizTimeoutError(schemaPath);\n        reject(error);\n      };\n      const onErrorFuncs: any[] = [];\n\n      this.Obniz.once(\"close\", onObnizClosed);\n      if (option!.queue) {\n        this.onceQueue(schemaPath as any, onDataReceived);\n      } else {\n        this.once(schemaPath as any, onDataReceived);\n      }\n\n      for (const path in option!.errors) {\n        const onError = () => {\n          clearListeners();\n          const error = new (option!.errors![path] as any)();\n          reject(error);\n        };\n        this.on(path as any, onError);\n        onErrorFuncs.push({ onError, path });\n      }\n      let timeoutHandler: number | undefined = setTimeout(onTimeout, option!.timeout);\n    });\n  }\n}\n"]}