{"version":3,"sources":["../src/obniz/libs/embeds/bleHci/protocol/peripheral/gatt.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AACH,OAAO,SAAS,MAAM,cAAc,CAAC;AAKrC,OAAO,YAAY,MAAM,eAAe,CAAC;AAyEzC,aAAK,cAAc,GAAG,WAAW,CAAC;AAClC;;GAEG;AACH,MAAM,CAAC,OAAO,OAAO,IAAK,SAAQ,YAAY,CAAC,cAAc,CAAC;IACrD,MAAM,EAAE,GAAG,CAAC;IACZ,IAAI,EAAE,GAAG,CAAC;IACV,qBAAqB,EAAE,GAAG,CAAC;IAC3B,qBAAqB,EAAE,GAAG,CAAC;IAC3B,oBAAoB,EAAE,GAAG,CAAC;IAC1B,QAAQ,EAAE,GAAG,CAAC;IACd,UAAU,CAAC,EAAE,SAAS,CAAC;IACvB,uBAAuB,EAAE,GAAG,CAAC;;IAc7B,WAAW,CAAC,QAAQ,EAAE,GAAG;IAwJzB,YAAY,CAAC,SAAS,EAAE,SAAS;IAUjC,eAAe,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,GAAG;IAQpC,cAAc;IAoBd,IAAI,CAAC,IAAI,EAAE,GAAG;IAQd,aAAa,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG;IAWnD,aAAa,CAAC,OAAO,EAAE,GAAG;IA+D1B,gBAAgB,CAAC,OAAO,EAAE,GAAG;IAqB7B,qBAAqB,CAAC,OAAO,EAAE,GAAG;IAkFlC,uBAAuB,CAAC,OAAO,EAAE,GAAG;IA4DpC,wBAAwB,CAAC,OAAO,EAAE,GAAG;IAqFrC,uBAAuB,CAAC,OAAO,EAAE,GAAG;IAoJpC,2BAA2B,CAAC,OAAO,EAAE,GAAG;IAiHxC,2BAA2B,CAAC,OAAO,EAAE,GAAG;IAmHxC,yBAAyB,CAAC,OAAO,EAAE,GAAG;IAyDtC,yBAAyB,CAAC,OAAO,EAAE,GAAG;IA6CtC,kBAAkB,CAAC,OAAO,EAAE,GAAG;CASvC","file":"gatt.d.ts","sourcesContent":["/**\n * @packageDocumentation\n *\n * @ignore\n */\nimport AclStream from \"./acl-stream\";\n\n// var debug = require('debug')('gatt');\nconst debug: any = () => {};\n\nimport EventEmitter from \"eventemitter3\";\n\n/* eslint-disable no-unused-vars */\n\n/**\n * @ignore\n */\nnamespace ATT {\n  export const OP_ERROR: any = 0x01;\n  export const OP_MTU_REQ: any = 0x02;\n  export const OP_MTU_RESP: any = 0x03;\n  export const OP_FIND_INFO_REQ: any = 0x04;\n  export const OP_FIND_INFO_RESP: any = 0x05;\n  export const OP_FIND_BY_TYPE_REQ: any = 0x06;\n  export const OP_FIND_BY_TYPE_RESP: any = 0x07;\n  export const OP_READ_BY_TYPE_REQ: any = 0x08;\n  export const OP_READ_BY_TYPE_RESP: any = 0x09;\n  export const OP_READ_REQ: any = 0x0a;\n  export const OP_READ_RESP: any = 0x0b;\n  export const OP_READ_BLOB_REQ: any = 0x0c;\n  export const OP_READ_BLOB_RESP: any = 0x0d;\n  export const OP_READ_MULTI_REQ: any = 0x0e;\n  export const OP_READ_MULTI_RESP: any = 0x0f;\n  export const OP_READ_BY_GROUP_REQ: any = 0x10;\n  export const OP_READ_BY_GROUP_RESP: any = 0x11;\n  export const OP_WRITE_REQ: any = 0x12;\n  export const OP_WRITE_RESP: any = 0x13;\n  export const OP_WRITE_CMD: any = 0x52;\n  export const OP_PREP_WRITE_REQ: any = 0x16;\n  export const OP_PREP_WRITE_RESP: any = 0x17;\n  export const OP_EXEC_WRITE_REQ: any = 0x18;\n  export const OP_EXEC_WRITE_RESP: any = 0x19;\n  export const OP_HANDLE_NOTIFY: any = 0x1b;\n  export const OP_HANDLE_IND: any = 0x1d;\n  export const OP_HANDLE_CNF: any = 0x1e;\n  export const OP_SIGNED_WRITE_CMD: any = 0xd2;\n\n  export const ECODE_SUCCESS: any = 0x00;\n  export const ECODE_INVALID_HANDLE: any = 0x01;\n  export const ECODE_READ_NOT_PERM: any = 0x02;\n  export const ECODE_WRITE_NOT_PERM: any = 0x03;\n  export const ECODE_INVALID_PDU: any = 0x04;\n  export const ECODE_AUTHENTICATION: any = 0x05;\n  export const ECODE_REQ_NOT_SUPP: any = 0x06;\n  export const ECODE_INVALID_OFFSET: any = 0x07;\n  export const ECODE_AUTHORIZATION: any = 0x08;\n  export const ECODE_PREP_QUEUE_FULL: any = 0x09;\n  export const ECODE_ATTR_NOT_FOUND: any = 0x0a;\n  export const ECODE_ATTR_NOT_LONG: any = 0x0b;\n  export const ECODE_INSUFF_ENCR_KEY_SIZE: any = 0x0c;\n  export const ECODE_INVAL_ATTR_VALUE_LEN: any = 0x0d;\n  export const ECODE_UNLIKELY: any = 0x0e;\n  export const ECODE_INSUFF_ENC: any = 0x0f;\n  export const ECODE_UNSUPP_GRP_TYPE: any = 0x10;\n  export const ECODE_INSUFF_RESOURCES: any = 0x11;\n\n  export const CID: any = 0x0004;\n}\n\n/**\n * @ignore\n */\nnamespace GATT {\n  export const PRIM_SVC_UUID: any = 0x2800;\n  export const INCLUDE_UUID: any = 0x2802;\n  export const CHARAC_UUID: any = 0x2803;\n\n  export const CLIENT_CHARAC_CFG_UUID: any = 0x2902;\n  export const SERVER_CHARAC_CFG_UUID: any = 0x2903;\n}\n\n/* eslint-enable no-unused-vars */\n\ntype GattEventTypes = \"mtuChange\";\n/**\n * @ignore\n */\nexport default class Gatt extends EventEmitter<GattEventTypes> {\n  public maxMtu: any;\n  public _mtu: any;\n  public _preparedWriteRequest: any;\n  public onAclStreamDataBinded: any;\n  public onAclStreamEndBinded: any;\n  public _handles: any;\n  public _aclStream?: AclStream;\n  public _lastIndicatedAttribute: any;\n\n  constructor() {\n    super();\n    this.maxMtu = 256;\n    this._mtu = 23;\n    this._preparedWriteRequest = null;\n\n    this.setServices([]);\n\n    this.onAclStreamDataBinded = this.onAclStreamData.bind(this);\n    this.onAclStreamEndBinded = this.onAclStreamEnd.bind(this);\n  }\n\n  public setServices(services: any) {\n    // var deviceName = process.env.BLENO_DEVICE_NAME || os.hostname();\n\n    // base services and characteristics\n    const allServices: any = [].concat(services);\n\n    this._handles = [];\n\n    let handle: any = 0;\n    let i: any;\n    let j: any;\n\n    for (i = 0; i < allServices.length; i++) {\n      const service: any = allServices[i];\n\n      handle++;\n      const serviceHandle: any = handle;\n\n      this._handles[serviceHandle] = {\n        type: \"service\",\n        uuid: service.uuid,\n        attribute: service,\n        startHandle: serviceHandle,\n        // endHandle filled in below\n      };\n\n      for (j = 0; j < service.characteristics.length; j++) {\n        const characteristic: any = service.characteristics[j];\n\n        let properties: any = 0;\n        let secure: any = 0;\n\n        if (characteristic.properties.indexOf(\"read\") !== -1) {\n          properties |= 0x02;\n\n          if (characteristic.secure.indexOf(\"read\") !== -1) {\n            secure |= 0x02;\n          }\n        }\n\n        if (characteristic.properties.indexOf(\"writeWithoutResponse\") !== -1) {\n          properties |= 0x04;\n\n          if (characteristic.secure.indexOf(\"writeWithoutResponse\") !== -1) {\n            secure |= 0x04;\n          }\n        }\n\n        if (characteristic.properties.indexOf(\"write\") !== -1) {\n          properties |= 0x08;\n\n          if (characteristic.secure.indexOf(\"write\") !== -1) {\n            secure |= 0x08;\n          }\n        }\n\n        if (characteristic.properties.indexOf(\"notify\") !== -1) {\n          properties |= 0x10;\n\n          if (characteristic.secure.indexOf(\"notify\") !== -1) {\n            secure |= 0x10;\n          }\n        }\n\n        if (characteristic.properties.indexOf(\"indicate\") !== -1) {\n          properties |= 0x20;\n\n          if (characteristic.secure.indexOf(\"indicate\") !== -1) {\n            secure |= 0x20;\n          }\n        }\n\n        handle++;\n        const characteristicHandle: any = handle;\n\n        handle++;\n        const characteristicValueHandle: any = handle;\n\n        this._handles[characteristicHandle] = {\n          type: \"characteristic\",\n          uuid: characteristic.uuid,\n          properties,\n          secure,\n          attribute: characteristic,\n          startHandle: characteristicHandle,\n          valueHandle: characteristicValueHandle,\n        };\n\n        this._handles[characteristicValueHandle] = {\n          type: \"characteristicValue\",\n          handle: characteristicValueHandle,\n          value: characteristic.value,\n        };\n\n        const hasCCCD: any = characteristic.descriptors.find((e: any) => e.uuid === \"2902\");\n        if (hasCCCD || properties & 0x30) {\n          // notify or indicate\n          // add client characteristic configuration descriptor\n\n          handle++;\n          const clientCharacteristicConfigurationDescriptorHandle: any = handle;\n          this._handles[clientCharacteristicConfigurationDescriptorHandle] = {\n            type: \"descriptor\",\n            handle: clientCharacteristicConfigurationDescriptorHandle,\n            uuid: \"2902\",\n            attribute: characteristic,\n            properties: 0x02 | 0x04 | 0x08, // read/write\n            secure: secure & 0x10 ? 0x02 | 0x04 | 0x08 : 0,\n            value: Buffer.from([0x00, 0x00]),\n          };\n        }\n\n        for (let k = 0; k < characteristic.descriptors.length; k++) {\n          const descriptor: any = characteristic.descriptors[k];\n          if (descriptor.uuid === \"2902\") {\n            continue;\n          }\n          handle++;\n          const descriptorHandle: any = handle;\n\n          this._handles[descriptorHandle] = {\n            type: \"descriptor\",\n            handle: descriptorHandle,\n            uuid: descriptor.uuid,\n            attribute: descriptor,\n            properties: 0x02, // read only\n            secure: 0x00,\n            value: descriptor.value,\n          };\n        }\n      }\n\n      this._handles[serviceHandle].endHandle = handle;\n    }\n\n    const debugHandles: any = [];\n    for (i = 0; i < this._handles.length; i++) {\n      handle = this._handles[i];\n\n      debugHandles[i] = {};\n      for (j in handle) {\n        if (Buffer.isBuffer(handle[j])) {\n          debugHandles[i][j] = handle[j] ? \"Buffer('\" + handle[j].toString(\"hex\") + \"', 'hex')\" : null;\n        } else if (j !== \"attribute\") {\n          debugHandles[i][j] = handle[j];\n        }\n      }\n    }\n\n    debug(\"handles = \" + JSON.stringify(debugHandles, null, 2));\n  }\n\n  public setAclStream(aclStream: AclStream) {\n    this._mtu = 23;\n    this._preparedWriteRequest = null;\n\n    this._aclStream = aclStream;\n\n    this._aclStream.on(\"data\", this.onAclStreamDataBinded);\n    this._aclStream.on(\"end\", this.onAclStreamEndBinded);\n  }\n\n  public onAclStreamData(cid: any, data?: any) {\n    if (cid !== ATT.CID) {\n      return;\n    }\n\n    this.handleRequest(data);\n  }\n\n  public onAclStreamEnd() {\n    this._aclStream!.removeListener(\"data\", this.onAclStreamDataBinded);\n    this._aclStream!.removeListener(\"end\", this.onAclStreamEndBinded);\n\n    for (let i = 0; i < this._handles.length; i++) {\n      if (\n        this._handles[i] &&\n        this._handles[i].type === \"descriptor\" &&\n        this._handles[i].uuid === \"2902\" &&\n        this._handles[i].value.readUInt16LE(0) !== 0\n      ) {\n        this._handles[i].value = Buffer.from([0x00, 0x00]);\n\n        if (this._handles[i].attribute && this._handles[i].attribute.emit) {\n          this._handles[i].attribute.emit(\"unsubscribe\");\n        }\n      }\n    }\n  }\n\n  public send(data: any) {\n    debug(\"send: \" + data.toString(\"hex\"));\n    if (!this._aclStream) {\n      throw new Error(\"_aclStream is not found\");\n    }\n    this._aclStream.write(ATT.CID, data);\n  }\n\n  public errorResponse(opcode: any, handle: any, status: any) {\n    const buf: any = Buffer.alloc(5);\n\n    buf.writeUInt8(ATT.OP_ERROR, 0);\n    buf.writeUInt8(opcode, 1);\n    buf.writeUInt16LE(handle, 2);\n    buf.writeUInt8(status, 4);\n\n    return buf;\n  }\n\n  public handleRequest(request: any) {\n    debug(\"handing request: \" + request.toString(\"hex\"));\n\n    const requestType: any = request[0];\n    let response: any = null;\n\n    switch (requestType) {\n      case ATT.OP_MTU_REQ:\n        response = this.handleMtuRequest(request);\n        break;\n\n      case ATT.OP_FIND_INFO_REQ:\n        response = this.handleFindInfoRequest(request);\n        break;\n\n      case ATT.OP_FIND_BY_TYPE_REQ:\n        response = this.handleFindByTypeRequest(request);\n        break;\n\n      case ATT.OP_READ_BY_TYPE_REQ:\n        response = this.handleReadByTypeRequest(request);\n        break;\n\n      case ATT.OP_READ_REQ:\n      case ATT.OP_READ_BLOB_REQ:\n        response = this.handleReadOrReadBlobRequest(request);\n        break;\n\n      case ATT.OP_READ_BY_GROUP_REQ:\n        response = this.handleReadByGroupRequest(request);\n        break;\n\n      case ATT.OP_WRITE_REQ:\n      case ATT.OP_WRITE_CMD:\n        response = this.handleWriteRequestOrCommand(request);\n        break;\n\n      case ATT.OP_PREP_WRITE_REQ:\n        response = this.handlePrepareWriteRequest(request);\n        break;\n\n      case ATT.OP_EXEC_WRITE_REQ:\n        response = this.handleExecuteWriteRequest(request);\n        break;\n\n      case ATT.OP_HANDLE_CNF:\n        response = this.handleConfirmation(request);\n        break;\n\n      default:\n      case ATT.OP_READ_MULTI_REQ:\n      case ATT.OP_SIGNED_WRITE_CMD:\n        response = this.errorResponse(requestType, 0x0000, ATT.ECODE_REQ_NOT_SUPP);\n        break;\n    }\n\n    if (response) {\n      debug(\"response: \" + response.toString(\"hex\"));\n\n      this.send(response);\n    }\n  }\n\n  public handleMtuRequest(request: any) {\n    let mtu: any = request.readUInt16LE(1);\n\n    if (mtu < 23) {\n      mtu = 23;\n    } else if (mtu > this.maxMtu) {\n      mtu = this.maxMtu;\n    }\n\n    this._mtu = mtu;\n\n    this.emit(\"mtuChange\", this._mtu);\n\n    const response: any = Buffer.alloc(3);\n\n    response.writeUInt8(ATT.OP_MTU_RESP, 0);\n    response.writeUInt16LE(mtu, 1);\n\n    return response;\n  }\n\n  public handleFindInfoRequest(request: any) {\n    let response: any = null;\n\n    const startHandle: any = request.readUInt16LE(1);\n    const endHandle: any = request.readUInt16LE(3);\n\n    const infos: any = [];\n    let uuid: any = null;\n    let i: any;\n\n    for (i = startHandle; i <= endHandle; i++) {\n      const handle: any = this._handles[i];\n\n      if (!handle) {\n        break;\n      }\n\n      uuid = null;\n\n      if (\"service\" === handle.type) {\n        uuid = \"2800\";\n      } else if (\"includedService\" === handle.type) {\n        uuid = \"2802\";\n      } else if (\"characteristic\" === handle.type) {\n        uuid = \"2803\";\n      } else if (\"characteristicValue\" === handle.type) {\n        uuid = this._handles[i - 1].uuid;\n      } else if (\"descriptor\" === handle.type) {\n        uuid = handle.uuid;\n      }\n\n      if (uuid) {\n        infos.push({\n          handle: i,\n          uuid,\n        });\n      }\n    }\n\n    if (infos.length) {\n      const uuidSize: any = infos[0].uuid.length / 2;\n      let numInfo: any = 1;\n\n      for (i = 1; i < infos.length; i++) {\n        if (infos[0].uuid.length !== infos[i].uuid.length) {\n          break;\n        }\n        numInfo++;\n      }\n\n      const lengthPerInfo: any = uuidSize === 2 ? 4 : 18;\n      const maxInfo: any = Math.floor((this._mtu - 2) / lengthPerInfo);\n      numInfo = Math.min(numInfo, maxInfo);\n\n      response = Buffer.alloc(2 + numInfo * lengthPerInfo);\n\n      response[0] = ATT.OP_FIND_INFO_RESP;\n      response[1] = uuidSize === 2 ? 0x01 : 0x2;\n\n      for (i = 0; i < numInfo; i++) {\n        const info: any = infos[i];\n\n        response.writeUInt16LE(info.handle, 2 + i * lengthPerInfo);\n\n        uuid = Buffer.from(\n          info.uuid\n            .match(/.{1,2}/g)\n            .reverse()\n            .join(\"\"),\n          \"hex\",\n        );\n        for (let j = 0; j < uuid.length; j++) {\n          response[2 + i * lengthPerInfo + 2 + j] = uuid[j];\n        }\n      }\n    } else {\n      response = this.errorResponse(ATT.OP_FIND_INFO_REQ, startHandle, ATT.ECODE_ATTR_NOT_FOUND);\n    }\n\n    return response;\n  }\n\n  public handleFindByTypeRequest(request: any) {\n    let response: any = null;\n\n    const startHandle: any = request.readUInt16LE(1);\n    const endHandle: any = request.readUInt16LE(3);\n    const uuid: any = request\n      .slice(5, 7)\n      .toString(\"hex\")\n      .match(/.{1,2}/g)\n      .reverse()\n      .join(\"\");\n    const value: any = request\n      .slice(7)\n      .toString(\"hex\")\n      .match(/.{1,2}/g)\n      .reverse()\n      .join(\"\");\n\n    const handles: any = [];\n    let handle: any;\n\n    for (let i = startHandle; i <= endHandle; i++) {\n      handle = this._handles[i];\n\n      if (!handle) {\n        break;\n      }\n\n      if (\"2800\" === uuid && handle.type === \"service\" && handle.uuid === value) {\n        handles.push({\n          start: handle.startHandle,\n          end: handle.endHandle,\n        });\n      }\n    }\n\n    if (handles.length) {\n      const lengthPerHandle: any = 4;\n      let numHandles: any = handles.length;\n      const maxHandles: any = Math.floor((this._mtu - 1) / lengthPerHandle);\n\n      numHandles = Math.min(numHandles, maxHandles);\n\n      response = Buffer.alloc(1 + numHandles * lengthPerHandle);\n\n      response[0] = ATT.OP_FIND_BY_TYPE_RESP;\n\n      for (let i = 0; i < numHandles; i++) {\n        handle = handles[i];\n\n        response.writeUInt16LE(handle.start, 1 + i * lengthPerHandle);\n        response.writeUInt16LE(handle.end, 1 + i * lengthPerHandle + 2);\n      }\n    } else {\n      response = this.errorResponse(ATT.OP_FIND_BY_TYPE_REQ, startHandle, ATT.ECODE_ATTR_NOT_FOUND);\n    }\n\n    return response;\n  }\n\n  public handleReadByGroupRequest(request: any) {\n    let response: any = null;\n\n    const startHandle: any = request.readUInt16LE(1);\n    const endHandle: any = request.readUInt16LE(3);\n    const uuid: any = request\n      .slice(5)\n      .toString(\"hex\")\n      .match(/.{1,2}/g)\n      .reverse()\n      .join(\"\");\n\n    debug(\n      \"read by group: startHandle = 0x\" +\n        startHandle.toString(16) +\n        \", endHandle = 0x\" +\n        endHandle.toString(16) +\n        \", uuid = 0x\" +\n        uuid.toString(16),\n    );\n\n    if (\"2800\" === uuid || \"2802\" === uuid) {\n      const services: any = [];\n      const type: any = \"2800\" === uuid ? \"service\" : \"includedService\";\n      let i: any;\n\n      for (i = startHandle; i <= endHandle; i++) {\n        const handle: any = this._handles[i];\n\n        if (!handle) {\n          break;\n        }\n\n        if (handle.type === type) {\n          services.push(handle);\n        }\n      }\n\n      if (services.length) {\n        const uuidSize: any = services[0].uuid.length / 2;\n        let numServices: any = 1;\n\n        for (i = 1; i < services.length; i++) {\n          if (services[0].uuid.length !== services[i].uuid.length) {\n            break;\n          }\n          numServices++;\n        }\n\n        const lengthPerService: any = uuidSize === 2 ? 6 : 20;\n        const maxServices: any = Math.floor((this._mtu - 2) / lengthPerService);\n        numServices = Math.min(numServices, maxServices);\n\n        response = Buffer.alloc(2 + numServices * lengthPerService);\n\n        response[0] = ATT.OP_READ_BY_GROUP_RESP;\n        response[1] = lengthPerService;\n\n        for (i = 0; i < numServices; i++) {\n          const service: any = services[i];\n\n          response.writeUInt16LE(service.startHandle, 2 + i * lengthPerService);\n          response.writeUInt16LE(service.endHandle, 2 + i * lengthPerService + 2);\n\n          const serviceUuid: any = Buffer.from(\n            service.uuid\n              .match(/.{1,2}/g)\n              .reverse()\n              .join(\"\"),\n            \"hex\",\n          );\n          for (let j = 0; j < serviceUuid.length; j++) {\n            response[2 + i * lengthPerService + 4 + j] = serviceUuid[j];\n          }\n        }\n      } else {\n        response = this.errorResponse(ATT.OP_READ_BY_GROUP_REQ, startHandle, ATT.ECODE_ATTR_NOT_FOUND);\n      }\n    } else {\n      response = this.errorResponse(ATT.OP_READ_BY_GROUP_REQ, startHandle, ATT.ECODE_UNSUPP_GRP_TYPE);\n    }\n\n    return response;\n  }\n\n  public handleReadByTypeRequest(request: any) {\n    let response: any = null;\n    const requestType: any = request[0];\n\n    const startHandle: any = request.readUInt16LE(1);\n    const endHandle: any = request.readUInt16LE(3);\n    const uuid: any = request\n      .slice(5)\n      .toString(\"hex\")\n      .match(/.{1,2}/g)\n      .reverse()\n      .join(\"\");\n    let i: any;\n    let handle: any;\n\n    debug(\n      \"read by type: startHandle = 0x\" +\n        startHandle.toString(16) +\n        \", endHandle = 0x\" +\n        endHandle.toString(16) +\n        \", uuid = 0x\" +\n        uuid.toString(16),\n    );\n\n    if (\"2803\" === uuid) {\n      const characteristics: any = [];\n\n      for (i = startHandle; i <= endHandle; i++) {\n        handle = this._handles[i];\n\n        if (!handle) {\n          break;\n        }\n\n        if (handle.type === \"characteristic\") {\n          characteristics.push(handle);\n        }\n      }\n\n      if (characteristics.length) {\n        const uuidSize: any = characteristics[0].uuid.length / 2;\n        let numCharacteristics: any = 1;\n\n        for (i = 1; i < characteristics.length; i++) {\n          if (characteristics[0].uuid.length !== characteristics[i].uuid.length) {\n            break;\n          }\n          numCharacteristics++;\n        }\n\n        const lengthPerCharacteristic: any = uuidSize === 2 ? 7 : 21;\n        const maxCharacteristics: any = Math.floor((this._mtu - 2) / lengthPerCharacteristic);\n        numCharacteristics = Math.min(numCharacteristics, maxCharacteristics);\n\n        response = Buffer.alloc(2 + numCharacteristics * lengthPerCharacteristic);\n\n        response[0] = ATT.OP_READ_BY_TYPE_RESP;\n        response[1] = lengthPerCharacteristic;\n\n        for (i = 0; i < numCharacteristics; i++) {\n          const characteristic: any = characteristics[i];\n\n          response.writeUInt16LE(characteristic.startHandle, 2 + i * lengthPerCharacteristic);\n          response.writeUInt8(characteristic.properties, 2 + i * lengthPerCharacteristic + 2);\n          response.writeUInt16LE(characteristic.valueHandle, 2 + i * lengthPerCharacteristic + 3);\n\n          const characteristicUuid: any = Buffer.from(\n            characteristic.uuid\n              .match(/.{1,2}/g)\n              .reverse()\n              .join(\"\"),\n            \"hex\",\n          );\n          for (let j = 0; j < characteristicUuid.length; j++) {\n            response[2 + i * lengthPerCharacteristic + 5 + j] = characteristicUuid[j];\n          }\n        }\n      } else {\n        response = this.errorResponse(ATT.OP_READ_BY_TYPE_REQ, startHandle, ATT.ECODE_ATTR_NOT_FOUND);\n      }\n    } else {\n      let handleAttribute: any = null;\n      let valueHandle: any = null;\n      let secure: any = false;\n\n      for (i = startHandle; i <= endHandle; i++) {\n        handle = this._handles[i];\n\n        if (!handle) {\n          break;\n        }\n\n        if (handle.type === \"characteristic\" && handle.uuid === uuid) {\n          handleAttribute = handle.attribute;\n          valueHandle = handle.valueHandle;\n          secure = handle.secure & 0x02;\n          break;\n        } else if (handle.type === \"descriptor\" && handle.uuid === uuid) {\n          valueHandle = i;\n          secure = handle.secure & 0x02;\n          break;\n        }\n      }\n\n      if (secure && !(this._aclStream && this._aclStream.encrypted)) {\n        response = this.errorResponse(ATT.OP_READ_BY_TYPE_REQ, startHandle, ATT.ECODE_AUTHENTICATION);\n      } else if (valueHandle) {\n        const callback: any = ((_valueHandle: any) => {\n          return (result: any, _data: any) => {\n            let callbackResponse: any = null;\n\n            if (ATT.ECODE_SUCCESS === result) {\n              const dataLength: any = Math.min(_data.length, this._mtu - 4);\n              callbackResponse = Buffer.alloc(4 + dataLength);\n\n              callbackResponse[0] = ATT.OP_READ_BY_TYPE_RESP;\n              callbackResponse[1] = dataLength + 2;\n              callbackResponse.writeUInt16LE(_valueHandle, 2);\n              for (i = 0; i < dataLength; i++) {\n                callbackResponse[4 + i] = _data[i];\n              }\n            } else {\n              callbackResponse = this.errorResponse(requestType, _valueHandle, result);\n            }\n\n            debug(\"read by type response: \" + callbackResponse.toString(\"hex\"));\n\n            this.send(callbackResponse);\n          };\n        })(valueHandle);\n\n        const data: any = this._handles[valueHandle].value;\n\n        if (data) {\n          callback(ATT.ECODE_SUCCESS, data);\n        } else if (handleAttribute) {\n          handleAttribute.emit(\"readRequest\", 0, callback);\n        } else {\n          callback(ATT.ECODE_UNLIKELY);\n        }\n      } else {\n        response = this.errorResponse(ATT.OP_READ_BY_TYPE_REQ, startHandle, ATT.ECODE_ATTR_NOT_FOUND);\n      }\n    }\n\n    return response;\n  }\n\n  public handleReadOrReadBlobRequest(request: any) {\n    let response: any = null;\n\n    const requestType: any = request[0];\n    const valueHandle: any = request.readUInt16LE(1);\n    const offset: any = requestType === ATT.OP_READ_BLOB_REQ ? request.readUInt16LE(3) : 0;\n\n    const handle: any = this._handles[valueHandle];\n    let i: any;\n\n    if (handle) {\n      let result: any = null;\n      let data: any = null;\n      const handleType: any = handle.type;\n\n      const callback: any = ((_requestType: any, _valueHandle: any) => {\n        return (_result: any, _data: any) => {\n          let callbackResponse: any = null;\n\n          if (ATT.ECODE_SUCCESS === _result) {\n            const dataLength: any = Math.min(_data.length, this._mtu - 1);\n            callbackResponse = Buffer.alloc(1 + dataLength);\n\n            callbackResponse[0] = _requestType === ATT.OP_READ_BLOB_REQ ? ATT.OP_READ_BLOB_RESP : ATT.OP_READ_RESP;\n            for (i = 0; i < dataLength; i++) {\n              callbackResponse[1 + i] = _data[i];\n            }\n          } else {\n            callbackResponse = this.errorResponse(_requestType, _valueHandle, _result);\n          }\n\n          debug(\"read response: \" + callbackResponse.toString(\"hex\"));\n\n          this.send(callbackResponse);\n        };\n      })(requestType, valueHandle);\n\n      if (handleType === \"service\" || handleType === \"includedService\") {\n        result = ATT.ECODE_SUCCESS;\n        data = Buffer.from(\n          handle.uuid\n            .match(/.{1,2}/g)\n            .reverse()\n            .join(\"\"),\n          \"hex\",\n        );\n      } else if (handleType === \"characteristic\") {\n        const uuid: any = Buffer.from(\n          handle.uuid\n            .match(/.{1,2}/g)\n            .reverse()\n            .join(\"\"),\n          \"hex\",\n        );\n\n        result = ATT.ECODE_SUCCESS;\n        data = Buffer.alloc(3 + uuid.length);\n        data.writeUInt8(handle.properties, 0);\n        data.writeUInt16LE(handle.valueHandle, 1);\n\n        for (i = 0; i < uuid.length; i++) {\n          data[i + 3] = uuid[i];\n        }\n      } else if (handleType === \"characteristicValue\" || handleType === \"descriptor\") {\n        let handleProperties: any = handle.properties;\n        let handleSecure: any = handle.secure;\n        let handleAttribute: any = handle.attribute;\n        if (handleType === \"characteristicValue\") {\n          handleProperties = this._handles[valueHandle - 1].properties;\n          handleSecure = this._handles[valueHandle - 1].secure;\n          handleAttribute = this._handles[valueHandle - 1].attribute;\n        }\n\n        if (handleProperties & 0x02) {\n          if (handleSecure & 0x02 && !(this._aclStream && this._aclStream.encrypted)) {\n            result = ATT.ECODE_AUTHENTICATION;\n          } else {\n            data = handle.value;\n\n            if (data) {\n              result = ATT.ECODE_SUCCESS;\n            } else {\n              handleAttribute.emit(\"readRequest\", offset, callback);\n            }\n          }\n        } else {\n          result = ATT.ECODE_READ_NOT_PERM; // non-readable\n        }\n      }\n\n      if (data && typeof data === \"string\") {\n        data = Buffer.from(data);\n      }\n\n      if (result === ATT.ECODE_SUCCESS && data && offset) {\n        if (data.length < offset) {\n          result = ATT.ECODE_INVALID_OFFSET;\n          data = null;\n        } else {\n          data = data.slice(offset);\n        }\n      }\n\n      if (result !== null) {\n        callback(result, data);\n      }\n    } else {\n      response = this.errorResponse(requestType, valueHandle, ATT.ECODE_INVALID_HANDLE);\n    }\n\n    return response;\n  }\n\n  public handleWriteRequestOrCommand(request: any) {\n    let response: any = null;\n\n    const requestType: any = request[0];\n    const withoutResponse: any = requestType === ATT.OP_WRITE_CMD;\n    const valueHandle: any = request.readUInt16LE(1);\n    const data: any = request.slice(3);\n    const offset: any = 0;\n\n    let handle: any = this._handles[valueHandle];\n\n    if (handle) {\n      if (handle.type === \"characteristicValue\") {\n        handle = this._handles[valueHandle - 1];\n      }\n\n      const handleProperties: any = handle.properties;\n      const handleSecure: any = handle.secure;\n\n      if (handleProperties && (withoutResponse ? handleProperties & 0x04 : handleProperties & 0x08)) {\n        const callback: any = ((_requestType: any, _valueHandle: any, _withoutResponse: any) => {\n          return (result: any) => {\n            if (!_withoutResponse) {\n              let callbackResponse: any = null;\n\n              if (ATT.ECODE_SUCCESS === result) {\n                callbackResponse = Buffer.from([ATT.OP_WRITE_RESP]);\n              } else {\n                callbackResponse = this.errorResponse(_requestType, _valueHandle, result);\n              }\n\n              debug(\"write response: \" + callbackResponse.toString(\"hex\"));\n\n              this.send(callbackResponse);\n            }\n          };\n        })(requestType, valueHandle, withoutResponse);\n\n        if (handleSecure & (withoutResponse ? 0x04 : 0x08) && !(this._aclStream && this._aclStream.encrypted)) {\n          response = this.errorResponse(requestType, valueHandle, ATT.ECODE_AUTHENTICATION);\n        } else if (handle.type === \"descriptor\" || handle.uuid === \"2902\") {\n          let result: any = null;\n\n          if (data.length !== 2) {\n            result = ATT.ECODE_INVAL_ATTR_VALUE_LEN;\n          } else {\n            const value: any = data.readUInt16LE(0);\n            const handleAttribute: any = handle.attribute;\n\n            handle.value = data;\n\n            if (value & 0x0003) {\n              const updateValueCallback: any = ((_valueHandle: any, _attribute: any) => {\n                return (_data: any) => {\n                  const dataLength: any = Math.min(_data.length, this._mtu - 3);\n                  const useNotify: any = _attribute.properties.indexOf(\"notify\") !== -1;\n                  const useIndicate: any = _attribute.properties.indexOf(\"indicate\") !== -1;\n                  let i: any;\n\n                  if (useNotify) {\n                    const notifyMessage: any = Buffer.alloc(3 + dataLength);\n\n                    notifyMessage.writeUInt8(ATT.OP_HANDLE_NOTIFY, 0);\n                    notifyMessage.writeUInt16LE(_valueHandle, 1);\n\n                    for (i = 0; i < dataLength; i++) {\n                      notifyMessage[3 + i] = _data[i];\n                    }\n\n                    debug(\"notify message: \" + notifyMessage.toString(\"hex\"));\n                    this.send(notifyMessage);\n\n                    _attribute.emit(\"notify\");\n                  } else if (useIndicate) {\n                    const indicateMessage: any = Buffer.alloc(3 + dataLength);\n\n                    indicateMessage.writeUInt8(ATT.OP_HANDLE_IND, 0);\n                    indicateMessage.writeUInt16LE(_valueHandle, 1);\n\n                    for (i = 0; i < dataLength; i++) {\n                      indicateMessage[3 + i] = _data[i];\n                    }\n\n                    this._lastIndicatedAttribute = _attribute;\n\n                    debug(\"indicate message: \" + indicateMessage.toString(\"hex\"));\n                    this.send(indicateMessage);\n                  }\n                };\n              })(valueHandle - 1, handleAttribute);\n\n              if (handleAttribute.emit) {\n                handleAttribute.emit(\"subscribe\", this._mtu - 3, updateValueCallback);\n              }\n            } else {\n              handleAttribute.emit(\"unsubscribe\");\n            }\n\n            result = ATT.ECODE_SUCCESS;\n          }\n\n          callback(result);\n        } else {\n          handle.attribute.emit(\"writeRequest\", data, offset, withoutResponse, callback);\n        }\n      } else {\n        response = this.errorResponse(requestType, valueHandle, ATT.ECODE_WRITE_NOT_PERM);\n      }\n    } else {\n      response = this.errorResponse(requestType, valueHandle, ATT.ECODE_INVALID_HANDLE);\n    }\n\n    return response;\n  }\n\n  public handlePrepareWriteRequest(request: any) {\n    let response: any = null;\n\n    const requestType: any = request[0];\n    const valueHandle: any = request.readUInt16LE(1);\n    const offset: any = request.readUInt16LE(3);\n    const data: any = request.slice(5);\n\n    let handle: any = this._handles[valueHandle];\n\n    if (handle) {\n      if (handle.type === \"characteristicValue\") {\n        handle = this._handles[valueHandle - 1];\n\n        const handleProperties: any = handle.properties;\n        const handleSecure: any = handle.secure;\n\n        if (handleProperties && handleProperties & 0x08) {\n          if (handleSecure & 0x08 && !(this._aclStream && this._aclStream.encrypted)) {\n            response = this.errorResponse(requestType, valueHandle, ATT.ECODE_AUTHENTICATION);\n          } else if (this._preparedWriteRequest) {\n            if (this._preparedWriteRequest.handle !== handle) {\n              response = this.errorResponse(requestType, valueHandle, ATT.ECODE_UNLIKELY);\n            } else if (offset === this._preparedWriteRequest.offset + this._preparedWriteRequest.data.length) {\n              this._preparedWriteRequest.data = Buffer.concat([this._preparedWriteRequest.data, data]);\n\n              response = Buffer.alloc(request.length);\n              request.copy(response);\n              response[0] = ATT.OP_PREP_WRITE_RESP;\n            } else {\n              response = this.errorResponse(requestType, valueHandle, ATT.ECODE_INVALID_OFFSET);\n            }\n          } else {\n            this._preparedWriteRequest = {\n              handle,\n              valueHandle,\n              offset,\n              data,\n            };\n\n            response = Buffer.alloc(request.length);\n            request.copy(response);\n            response[0] = ATT.OP_PREP_WRITE_RESP;\n          }\n        } else {\n          response = this.errorResponse(requestType, valueHandle, ATT.ECODE_WRITE_NOT_PERM);\n        }\n      } else {\n        response = this.errorResponse(requestType, valueHandle, ATT.ECODE_ATTR_NOT_LONG);\n      }\n    } else {\n      response = this.errorResponse(requestType, valueHandle, ATT.ECODE_INVALID_HANDLE);\n    }\n\n    return response;\n  }\n\n  public handleExecuteWriteRequest(request: any) {\n    let response: any = null;\n\n    const requestType: any = request[0];\n    const flag: any = request[1];\n\n    if (this._preparedWriteRequest) {\n      if (flag === 0x00) {\n        response = Buffer.from([ATT.OP_EXEC_WRITE_RESP]);\n      } else if (flag === 0x01) {\n        const callback: any = ((_requestType: any, _valueHandle: any) => {\n          return (result: any) => {\n            let callbackResponse: any = null;\n\n            if (ATT.ECODE_SUCCESS === result) {\n              callbackResponse = Buffer.from([ATT.OP_EXEC_WRITE_RESP]);\n            } else {\n              callbackResponse = this.errorResponse(_requestType, _valueHandle, result);\n            }\n\n            debug(\"execute write response: \" + callbackResponse.toString(\"hex\"));\n\n            this.send(callbackResponse);\n          };\n        })(requestType, this._preparedWriteRequest.valueHandle);\n\n        this._preparedWriteRequest.handle.attribute.emit(\n          \"writeRequest\",\n          this._preparedWriteRequest.data,\n          this._preparedWriteRequest.offset,\n          false,\n          callback,\n        );\n      } else {\n        response = this.errorResponse(requestType, 0x0000, ATT.ECODE_UNLIKELY);\n      }\n\n      this._preparedWriteRequest = null;\n    } else {\n      response = this.errorResponse(requestType, 0x0000, ATT.ECODE_UNLIKELY);\n    }\n\n    return response;\n  }\n\n  public handleConfirmation(request: any) {\n    if (this._lastIndicatedAttribute) {\n      if (this._lastIndicatedAttribute.emit) {\n        this._lastIndicatedAttribute.emit(\"indicate\");\n      }\n\n      this._lastIndicatedAttribute = null;\n    }\n  }\n}\n"]}