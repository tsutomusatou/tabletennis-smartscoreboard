{"version":3,"sources":["../src/obniz/libs/embeds/bleHci/protocol/central/gap.ts"],"names":[],"mappings":"AAaA,OAAO,YAAY,MAAM,eAAe,CAAC;AAEzC,OAAO,GAAG,MAAM,QAAQ,CAAC;AAEzB,aAAK,aAAa,GAAG,UAAU,GAAG,UAAU,CAAC;AAE7C;;GAEG;AACH,cAAM,GAAI,SAAQ,YAAY,CAAC,aAAa,CAAC;IACpC,IAAI,EAAE,GAAG,CAAC;IACV,UAAU,EAAE,IAAI,GAAG,UAAU,GAAG,SAAS,GAAG,UAAU,GAAG,SAAS,CAAC;IACnE,qBAAqB,EAAE,IAAI,GAAG,OAAO,CAAC;IACtC,YAAY,EAAE,GAAG,CAAC;gBAEb,GAAG,EAAE,GAAG;IAWP,iBAAiB,CAAC,eAAe,EAAE,OAAO,EAAE,UAAU,EAAE,OAAO;IAuB/D,gBAAgB;IAKtB,wBAAwB,CAAC,MAAM,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,GAAG;YA6MlG,kBAAkB;CAgBjC;AAED,eAAe,GAAG,CAAC","file":"gap.d.ts","sourcesContent":["/**\n * @packageDocumentation\n *\n * @ignore\n */\n// let debug = require('debug')('gap');\nimport ObnizBLEHci from \"../../hci\";\n\n/**\n * @ignore\n */\nconst debug: any = () => {};\n\nimport EventEmitter from \"eventemitter3\";\nimport { ObnizBleOpError } from \"../../../../../ObnizError\";\nimport Hci from \"../hci\";\n\ntype GapEventTypes = \"scanStop\" | \"discover\";\n\n/**\n * @ignore\n */\nclass Gap extends EventEmitter<GapEventTypes> {\n  public _hci: Hci;\n  public _scanState: null | \"starting\" | \"started\" | \"stopping\" | \"stopped\";\n  public _scanFilterDuplicates: null | boolean;\n  public _discoveries: any;\n\n  constructor(hci: Hci) {\n    super();\n    this._hci = hci;\n\n    this._scanState = null;\n    this._scanFilterDuplicates = null;\n    this._discoveries = {};\n\n    this._hci.on(\"leAdvertisingReport\", this.onHciLeAdvertisingReport.bind(this));\n  }\n\n  public async startScanningWait(allowDuplicates: boolean, activeScan: boolean) {\n    this._scanState = \"starting\";\n    this._scanFilterDuplicates = !allowDuplicates;\n    this._discoveries = {};\n    // Always set scan parameters before scanning\n    // https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=229737\n    // p106 - p107\n\n    try {\n      await this.setScanEnabledWait(false, true);\n    } catch (e) {\n      if (e instanceof ObnizBleOpError) {\n        // nop\n      } else {\n        throw e;\n      }\n    }\n\n    const setParamStatus = await this._hci.setScanParametersWait(activeScan);\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n    await this.setScanEnabledWait(true, this._scanFilterDuplicates);\n  }\n\n  public async stopScanningWait() {\n    this._scanState = \"stopping\";\n    await this._hci.setScanEnabledWait(false, true);\n  }\n\n  public onHciLeAdvertisingReport(status: any, type?: any, address?: any, addressType?: any, eir?: any, rssi?: any) {\n    const previouslyDiscovered: any = !!this._discoveries[address];\n    const advertisement: any = previouslyDiscovered\n      ? this._discoveries[address].advertisement\n      : {\n          localName: undefined,\n          txPowerLevel: undefined,\n          manufacturerData: undefined,\n          serviceData: [],\n          serviceUuids: [],\n          solicitationServiceUuids: [],\n          advertisementRaw: [],\n          scanResponseRaw: [],\n          raw: [],\n        };\n\n    let discoveryCount: any = previouslyDiscovered ? this._discoveries[address].count : 0;\n    let hasScanResponse: any = previouslyDiscovered ? this._discoveries[address].hasScanResponse : false;\n\n    if (type === 0x04) {\n      hasScanResponse = true;\n\n      if (eir.length > 0) {\n        advertisement.scanResponseRaw = Array.from(eir);\n      }\n    } else {\n      // reset service data every non-scan response event\n      advertisement.serviceData = [];\n      advertisement.serviceUuids = [];\n      advertisement.serviceSolicitationUuids = [];\n\n      if (eir.length > 0) {\n        advertisement.advertisementRaw = Array.from(eir);\n      }\n    }\n\n    discoveryCount++;\n\n    let i: any = 0;\n    let j: any = 0;\n    let serviceUuid: any = null;\n    let serviceSolicitationUuid: any = null;\n\n    while (i + 1 < eir.length) {\n      const length: any = eir.readUInt8(i);\n\n      if (length < 1) {\n        debug(\"invalid EIR data, length = \" + length);\n        break;\n      }\n\n      const eirType: any = eir.readUInt8(i + 1); // https://www.bluetooth.org/en-us/specification/assigned-numbers/generic-access-profile\n\n      if (i + length + 1 > eir.length) {\n        debug(\"invalid EIR data, out of range of buffer length\");\n        break;\n      }\n\n      const bytes: any = eir.slice(i + 2).slice(0, length - 1);\n\n      switch (eirType) {\n        case 0x02: // Incomplete List of 16-bit Service Class UUID\n        case 0x03: // Complete List of 16-bit Service Class UUIDs\n          for (j = 0; j < bytes.length; j += 2) {\n            serviceUuid = bytes.readUInt16LE(j).toString(16);\n            if (advertisement.serviceUuids.indexOf(serviceUuid) === -1) {\n              advertisement.serviceUuids.push(serviceUuid);\n            }\n          }\n          break;\n\n        case 0x06: // Incomplete List of 128-bit Service Class UUIDs\n        case 0x07: // Complete List of 128-bit Service Class UUIDs\n          for (j = 0; j < bytes.length; j += 16) {\n            serviceUuid = bytes\n              .slice(j, j + 16)\n              .toString(\"hex\")\n              .match(/.{1,2}/g)\n              .reverse()\n              .join(\"\");\n            if (advertisement.serviceUuids.indexOf(serviceUuid) === -1) {\n              advertisement.serviceUuids.push(serviceUuid);\n            }\n          }\n          break;\n\n        case 0x08: // Shortened Local Name\n        case 0x09: // Complete Local Name\n          advertisement.localName = bytes.toString(\"utf8\");\n          break;\n\n        case 0x0a: {\n          // Tx Power Level\n          advertisement.txPowerLevel = bytes.readInt8(0);\n          break;\n        }\n        case 0x14: {\n          // List of 16 bit solicitation UUIDs\n          for (j = 0; j < bytes.length; j += 2) {\n            serviceSolicitationUuid = bytes.readUInt16LE(j).toString(16);\n            if (advertisement.serviceSolicitationUuids.indexOf(serviceSolicitationUuid) === -1) {\n              advertisement.serviceSolicitationUuids.push(serviceSolicitationUuid);\n            }\n          }\n          break;\n        }\n        case 0x15: {\n          // List of 128 bit solicitation UUIDs\n          for (j = 0; j < bytes.length; j += 16) {\n            serviceSolicitationUuid = bytes\n              .slice(j, j + 16)\n              .toString(\"hex\")\n              .match(/.{1,2}/g)\n              .reverse()\n              .join(\"\");\n            if (advertisement.serviceSolicitationUuids.indexOf(serviceSolicitationUuid) === -1) {\n              advertisement.serviceSolicitationUuids.push(serviceSolicitationUuid);\n            }\n          }\n          break;\n        }\n        case 0x16: {\n          // 16-bit Service Data, there can be multiple occurences\n          const serviceDataUuid: any = bytes\n            .slice(0, 2)\n            .toString(\"hex\")\n            .match(/.{1,2}/g)\n            .reverse()\n            .join(\"\");\n          const serviceData: any = bytes.slice(2, bytes.length);\n\n          advertisement.serviceData.push({\n            uuid: serviceDataUuid,\n            data: serviceData,\n          });\n          break;\n        }\n        case 0x20: {\n          // 32-bit Service Data, there can be multiple occurences\n          const serviceData32Uuid: any = bytes\n            .slice(0, 4)\n            .toString(\"hex\")\n            .match(/.{1,2}/g)\n            .reverse()\n            .join(\"\");\n          const serviceData32: any = bytes.slice(4, bytes.length);\n\n          advertisement.serviceData.push({\n            uuid: serviceData32Uuid,\n            data: serviceData32,\n          });\n          break;\n        }\n        case 0x21: {\n          // 128-bit Service Data, there can be multiple occurences\n\n          const serviceData128Uuid: any = bytes\n            .slice(0, 16)\n            .toString(\"hex\")\n            .match(/.{1,2}/g)\n            .reverse()\n            .join(\"\");\n          const serviceData128: any = bytes.slice(16, bytes.length);\n\n          advertisement.serviceData.push({\n            uuid: serviceData128Uuid,\n            data: serviceData128,\n          });\n          break;\n        }\n        case 0x1f: // List of 32 bit solicitation UUIDs\n          for (j = 0; j < bytes.length; j += 4) {\n            serviceSolicitationUuid = bytes.readUInt32LE(j).toString(16);\n            if (advertisement.serviceSolicitationUuids.indexOf(serviceSolicitationUuid) === -1) {\n              advertisement.serviceSolicitationUuids.push(serviceSolicitationUuid);\n            }\n          }\n          break;\n\n        case 0xff: // Manufacturer Specific Data\n          advertisement.manufacturerData = bytes;\n          break;\n      }\n\n      i += length + 1;\n    }\n\n    debug(\"advertisement = \" + JSON.stringify(advertisement, null, 0));\n\n    const connectable: any =\n      type === 0x04 && previouslyDiscovered ? this._discoveries[address].connectable : type !== 0x03;\n\n    this._discoveries[address] = {\n      address,\n      addressType,\n      connectable,\n      advertisement,\n      rssi,\n      count: discoveryCount,\n      hasScanResponse,\n    };\n\n    this.emit(\"discover\", status, address, addressType, connectable, advertisement, rssi);\n  }\n\n  private async setScanEnabledWait(enabled: boolean, filterDuplicates: boolean) {\n    const scanStopStatus = await this._hci.setScanEnabledWait(enabled, true);\n\n    // Check the status we got from the command complete function.\n    if (scanStopStatus !== 0) {\n      // If it is non-zero there was an error, and we should not change\n      // our status as a result.\n      // throw new ObnizBleOpError();\n    } else {\n      if (this._scanState === \"starting\") {\n        this._scanState = \"started\";\n      } else if (this._scanState === \"stopping\") {\n        this._scanState = \"stopped\";\n      }\n    }\n  }\n}\n\nexport default Gap;\n"]}