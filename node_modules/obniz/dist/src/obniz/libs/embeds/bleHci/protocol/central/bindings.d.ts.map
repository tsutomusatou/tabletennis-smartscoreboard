{"version":3,"sources":["../src/obniz/libs/embeds/bleHci/protocol/central/bindings.ts"],"names":[],"mappings":"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","file":"bindings.d.ts","sourcesContent":["/**\n * @packageDocumentation\n *\n * @ignore\n */\n// var debug = require('debug')('bindings');\n\nimport EventEmitter from \"eventemitter3\";\n\nimport { ObnizBleHciStateError, ObnizBleUnknownPeripheralError, ObnizError } from \"../../../../../ObnizError\";\nimport { BleDeviceAddress, BleDeviceAddressType, Handle, UUID } from \"../../bleTypes\";\nimport Hci from \"../hci\";\nimport AclStream from \"./acl-stream\";\nimport Gap from \"./gap\";\nimport Gatt from \"./gatt\";\nimport Signaling from \"./signaling\";\n\ntype NobleBindingsEventType =\n  // notify from peripheral\n  | \"discover\" // for onfind\n  | \"disconnect\"\n  | \"stateChange\"\n  | \"notification\"\n  | \"handleNotify\";\n\n/**\n * @ignore\n */\nclass NobleBindings extends EventEmitter<NobleBindingsEventType> {\n  public _connectable: any;\n\n  private _state: any;\n  private _addresses: { [uuid: string]: BleDeviceAddress };\n  private _addresseTypes: { [uuid: string]: BleDeviceAddressType };\n  private _connectPromises: Array<Promise<any>>;\n  private _handles: any;\n  private _gatts: { [handle: string]: Gatt };\n  private _aclStreams: { [key: string]: AclStream };\n  private _signalings: any;\n  private _hci: Hci;\n  private _gap: Gap;\n  private _scanServiceUuids: any;\n\n  constructor(hciProtocol: any) {\n    super();\n    this._state = null;\n\n    this._addresses = {};\n    this._addresseTypes = {};\n    this._connectable = {};\n\n    this._connectPromises = [];\n\n    this._handles = {};\n    this._gatts = {};\n    this._aclStreams = {};\n    this._signalings = {};\n\n    this._hci = hciProtocol;\n    this._gap = new Gap(this._hci);\n  }\n  public debugHandler: any = () => {};\n\n  public addPeripheralData(uuid: UUID, addressType: BleDeviceAddressType) {\n    if (!this._addresses[uuid]) {\n      const address: any = uuid.match(/.{1,2}/g)!.join(\":\");\n      this._addresses[uuid] = address;\n      this._addresseTypes[uuid] = addressType;\n      this._connectable[uuid] = true;\n    }\n  }\n\n  public async startScanningWait(serviceUuids: any, allowDuplicates: any, activeScan: boolean) {\n    this._scanServiceUuids = serviceUuids || [];\n\n    await this._gap.startScanningWait(allowDuplicates, activeScan);\n  }\n\n  public async stopScanningWait() {\n    await this._gap.stopScanningWait();\n  }\n\n  public connectWait(peripheralUuid: any) {\n    const address: any = this._addresses[peripheralUuid];\n    const addressType: any = this._addresseTypes[peripheralUuid];\n\n    const doPromise = Promise.all(this._connectPromises)\n      .catch((error) => {\n        // nothing\n      })\n      .then(() => {\n        return this._hci.createLeConnWait(address, addressType, 90 * 1000); // connection timeout for 90 secs.\n      })\n      .then((result) => {\n        return this.onLeConnComplete(\n          result.status,\n          result.handle,\n          result.role,\n          result.addressType,\n          result.address,\n          result.interval,\n          result.latency,\n          result.supervisionTimeout,\n          result.masterClockAccuracy,\n        );\n      })\n      .then(\n        (result) => {\n          this._connectPromises = this._connectPromises.filter((e) => e === doPromise);\n          return Promise.resolve(result);\n        },\n        (error) => {\n          this._connectPromises = this._connectPromises.filter((e) => e === doPromise);\n          return Promise.reject(error);\n        },\n      );\n    this._connectPromises.push(doPromise);\n    return doPromise;\n  }\n\n  public disconnect(peripheralUuid: any) {\n    this._hci.disconnect(this._handles[peripheralUuid]);\n  }\n\n  public async updateRssiWait(peripheralUuid: UUID) {\n    const rssi = await this._hci.readRssiWait(this._handles[peripheralUuid]);\n    return rssi;\n  }\n\n  public init() {\n    this._gap.on(\"discover\", this.onDiscover.bind(this));\n\n    this._hci.on(\"stateChange\", this.onStateChange.bind(this));\n    this._hci.on(\"disconnComplete\", this.onDisconnComplete.bind(this));\n    this._hci.on(\"aclDataPkt\", this.onAclDataPkt.bind(this));\n  }\n\n  public onStateChange(state: any) {\n    if (this._state === state) {\n      return;\n    }\n    this._state = state;\n\n    if (state === \"unauthorized\") {\n      console.log(\"noble warning: adapter state unauthorized, please run as root or with sudo\");\n      console.log(\"               or see README for information on running without root/sudo:\");\n      console.log(\"               https://github.com/sandeepmistry/noble#running-on-linux\");\n    } else if (state === \"unsupported\") {\n      console.log(\"noble warning: adapter does not support Bluetooth Low Energy (BLE, Bluetooth Smart).\");\n      console.log(\"               Try to run with environment variable:\");\n      console.log(\"               [sudo] NOBLE_HCI_DEVICE_ID=x node ...\");\n    }\n\n    this.emit(\"stateChange\", state);\n  }\n\n  public onDiscover(status: any, address?: any, addressType?: any, connectable?: any, advertisement?: any, rssi?: any) {\n    if (this._scanServiceUuids === undefined) {\n      return;\n    }\n\n    let serviceUuids: any = advertisement.serviceUuids || [];\n    const serviceData: any = advertisement.serviceData || [];\n    let hasScanServiceUuids: any = this._scanServiceUuids.length === 0;\n\n    if (!hasScanServiceUuids) {\n      let i: any;\n\n      serviceUuids = serviceUuids.slice();\n\n      for (i in serviceData) {\n        serviceUuids.push(serviceData[i].uuid);\n      }\n\n      for (i in serviceUuids) {\n        hasScanServiceUuids = this._scanServiceUuids.indexOf(serviceUuids[i]) !== -1;\n\n        if (hasScanServiceUuids) {\n          break;\n        }\n      }\n    }\n\n    if (hasScanServiceUuids) {\n      const uuid: any = address.split(\":\").join(\"\");\n      this._addresses[uuid] = address;\n      this._addresseTypes[uuid] = addressType;\n      this._connectable[uuid] = connectable;\n\n      this.emit(\"discover\", uuid, address, addressType, connectable, advertisement, rssi);\n    }\n  }\n\n  public async onLeConnComplete(\n    status: any,\n    handle?: any,\n    role?: any,\n    addressType?: any,\n    address?: any,\n    interval?: any,\n    latency?: any,\n    supervisionTimeout?: any,\n    masterClockAccuracy?: any,\n  ) {\n    if (role !== 0) {\n      // not master, ignore\n      return;\n    }\n\n    let uuid: any = null;\n\n    if (status !== 0) {\n      throw new ObnizBleHciStateError(status);\n    }\n    uuid = address\n      .split(\":\")\n      .join(\"\")\n      .toLowerCase();\n\n    const aclStream: AclStream = new AclStream(\n      this._hci,\n      handle,\n      this._hci.addressType,\n      this._hci.address,\n      addressType,\n      address,\n    );\n    aclStream.debugHandler = (text: any) => {\n      this.debug(text);\n    };\n    const gatt = new Gatt(address, aclStream);\n    const signaling: any = new Signaling(handle, aclStream);\n\n    this._gatts[uuid] = this._gatts[handle] = gatt;\n    this._signalings[uuid] = this._signalings[handle] = signaling;\n    this._aclStreams[handle] = aclStream;\n    this._handles[uuid] = handle;\n    this._handles[handle] = uuid;\n\n    this._gatts[handle].on(\"notification\", this.onNotification.bind(this));\n    this._gatts[handle].on(\"handleNotify\", this.onHandleNotify.bind(this));\n\n    this._signalings[handle].on(\"connectionParameterUpdateRequest\", this.onConnectionParameterUpdateWait.bind(this));\n\n    await this._gatts[handle].exchangeMtuWait(256);\n    // public onMtu(address: any, mtu?: any) {}\n  }\n\n  public onDisconnComplete(handle: any, reason: number) {\n    const uuid: any = this._handles[handle];\n\n    if (uuid) {\n      const error = new ObnizBleHciStateError(reason, { peripheralAddress: uuid });\n      this._gatts[handle].onEnd(error);\n      this._gatts[handle].removeAllListeners();\n      this._signalings[handle].removeAllListeners();\n\n      delete this._gatts[uuid];\n      delete this._gatts[handle];\n      delete this._signalings[uuid];\n      delete this._signalings[handle];\n      delete this._aclStreams[handle];\n      delete this._handles[uuid];\n      delete this._handles[handle];\n\n      this.emit(\"disconnect\", uuid, error); // TODO: handle reason?\n    } else {\n      // maybe disconnect as peripheral\n      // console.warn(\n      //   'noble warning: unknown handle ' + handle + ' disconnected!'\n      // );\n    }\n  }\n\n  public onAclDataPkt(handle: any, cid?: any, data?: any) {\n    const aclStream: AclStream = this._aclStreams[handle];\n\n    if (aclStream) {\n      aclStream.push(cid, data);\n    }\n  }\n\n  public async discoverServicesWait(peripheralUuid: any, uuids?: any) {\n    const gatt: Gatt = this.getGatt(peripheralUuid);\n\n    const services = await gatt.discoverServicesWait(uuids || []);\n    return services;\n  }\n\n  public async discoverIncludedServicesWait(peripheralUuid: string, serviceUuid: UUID, serviceUuids: UUID[]) {\n    const gatt: Gatt = this.getGatt(peripheralUuid);\n\n    const services = gatt.discoverIncludedServicesWait(serviceUuid, serviceUuids || []);\n    return services;\n  }\n\n  public async discoverCharacteristicsWait(peripheralUuid: any, serviceUuid: any, characteristicUuids?: any) {\n    const gatt: Gatt = this.getGatt(peripheralUuid);\n    const chars = await gatt.discoverCharacteristicsWait(serviceUuid, characteristicUuids || []);\n    return chars;\n  }\n\n  public async readWait(peripheralUuid: any, serviceUuid: any, characteristicUuid: any): Promise<Buffer> {\n    const gatt: Gatt = this.getGatt(peripheralUuid);\n    const data = await gatt.readWait(serviceUuid, characteristicUuid);\n    return data;\n  }\n\n  public async writeWait(\n    peripheralUuid: any,\n    serviceUuid: any,\n    characteristicUuid: any,\n    data: any,\n    withoutResponse: any,\n  ): Promise<void> {\n    const gatt: Gatt = this.getGatt(peripheralUuid);\n    await gatt.writeWait(serviceUuid, characteristicUuid, data, withoutResponse);\n  }\n\n  public async broadcastWait(\n    peripheralUuid: any,\n    serviceUuid: any,\n    characteristicUuid: any,\n    broadcast: any,\n  ): Promise<void> {\n    const gatt: Gatt = this.getGatt(peripheralUuid);\n    await gatt.broadcastWait(serviceUuid, characteristicUuid, broadcast);\n  }\n\n  public async notifyWait(peripheralUuid: any, serviceUuid: any, characteristicUuid: any, notify: any) {\n    const gatt: Gatt = this.getGatt(peripheralUuid);\n    await gatt.notifyWait(serviceUuid, characteristicUuid, notify);\n  }\n\n  public onNotification(address: any, serviceUuid?: any, characteristicUuid?: any, data?: any) {\n    const uuid: any = address\n      .split(\":\")\n      .join(\"\")\n      .toLowerCase();\n\n    this.emit(\"notification\", uuid, serviceUuid, characteristicUuid, data, true, true);\n  }\n\n  public async discoverDescriptorsWait(peripheralUuid: any, serviceUuid: any, characteristicUuid: any) {\n    const gatt: Gatt = this.getGatt(peripheralUuid);\n    const descriptors = await gatt.discoverDescriptorsWait(serviceUuid, characteristicUuid);\n    return descriptors;\n  }\n\n  public async readValueWait(peripheralUuid: any, serviceUuid: any, characteristicUuid: any, descriptorUuid: any) {\n    const gatt: Gatt = this.getGatt(peripheralUuid);\n    const resp = await gatt.readValueWait(serviceUuid, characteristicUuid, descriptorUuid);\n    return resp;\n  }\n\n  public async writeValueWait(\n    peripheralUuid: any,\n    serviceUuid: any,\n    characteristicUuid: any,\n    descriptorUuid: any,\n    data: any,\n  ) {\n    const gatt: Gatt = this.getGatt(peripheralUuid);\n    await gatt.writeValueWait(serviceUuid, characteristicUuid, descriptorUuid, data);\n  }\n\n  public async readHandleWait(peripheralUuid: any, attHandle: any): Promise<Buffer> {\n    const gatt: Gatt = this.getGatt(peripheralUuid);\n    const data = await gatt.readHandleWait(attHandle);\n    return data;\n  }\n\n  public async writeHandleWait(peripheralUuid: any, attHandle: any, data: any, withoutResponse: any): Promise<void> {\n    const gatt: Gatt = this.getGatt(peripheralUuid);\n    await gatt.writeHandleWait(attHandle, data, withoutResponse);\n  }\n\n  public onHandleNotify(address: any, handle?: any, data?: any) {\n    const uuid: any = address\n      .split(\":\")\n      .join(\"\")\n      .toLowerCase();\n\n    this.emit(\"handleNotify\", uuid, handle, data);\n  }\n\n  public async onConnectionParameterUpdateWait(\n    handle: Handle,\n    minInterval?: any,\n    maxInterval?: any,\n    latency?: any,\n    supervisionTimeout?: any,\n  ) {\n    await this._hci.connUpdateLeWait(handle, minInterval, maxInterval, latency, supervisionTimeout);\n    // this.onLeConnUpdateComplete(); is nop\n  }\n\n  public async pairingWait(peripheralUuid: any, options?: any): Promise<string> {\n    options = options || {};\n    const gatt: Gatt = this.getGatt(peripheralUuid);\n    const result = await gatt.encryptWait(options);\n    return result;\n  }\n\n  public async setPairingOption(peripheralUuid: any, options: any) {\n    options = options || {};\n    const gatt: Gatt = this.getGatt(peripheralUuid);\n    gatt.setEncryptOption(options);\n  }\n\n  private getGatt(peripheralUuid: any): Gatt {\n    const handle = this._handles[peripheralUuid];\n    const gatt: Gatt = this._gatts[handle];\n\n    if (!gatt) {\n      throw new ObnizBleUnknownPeripheralError(peripheralUuid);\n    }\n    return gatt;\n  }\n\n  private debug(text: any) {\n    this.debugHandler(`${text}`);\n  }\n}\n\nexport default NobleBindings;\n"]}