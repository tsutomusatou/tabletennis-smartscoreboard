{"version":3,"sources":["../src/obniz/libs/measurements/measure.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,KAAK,MAAM,aAAa,CAAC;AAChC,OAAO,EAAE,iBAAiB,EAAE,MAAM,qBAAqB,CAAC;AAIxD,MAAM,WAAW,kBAAkB;IACjC,IAAI,EAAE,OAAO,CAAC;IACd,MAAM,EAAE,MAAM,CAAC;CAChB;AAED,aAAK,uBAAuB,GAAG,CAAC,kBAAkB,EAAE,kBAAkB,CAAC,CAAC;AAExE,MAAM,WAAW,mBAAmB;IAClC;;;;;;;OAOG;IACH,QAAQ,EAAE,MAAM,CAAC;IAEjB;;;OAGG;IACH,KAAK,EAAE,UAAU,GAAG,UAAU,CAAC;IAE/B;;;;OAIG;IACH,WAAW,EAAE,MAAM,CAAC;IAEpB;;;OAGG;IACH,OAAO,EAAE,MAAM,CAAC;IAEhB;;;OAGG;IACH,aAAa,EAAE,MAAM,CAAC;IAEtB;;;OAGG;IACH,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB;;;;;;;;;;;;;;;;;;;;;OAqBG;IACH,QAAQ,CAAC,EAAE,CAAC,KAAK,EAAE,uBAAuB,KAAK,IAAI,CAAC;CACrD;AAED;;;GAGG;AACH,MAAM,CAAC,OAAO,OAAO,YAAa,SAAQ,iBAAiB;IACzD,OAAO,CAAC,SAAS,CAAmD;IACpE,OAAO,CAAC,MAAM,CAAC,CAAsB;gBAEzB,KAAK,EAAE,KAAK;IAKxB;;;OAGG;IACI,MAAM;IAIb;;;;;;;;;;;;;;;;;;;;;;;;OAwBG;IACI,IAAI,CAAC,MAAM,EAAE,mBAAmB;IAsChC,cAAc,IAAI,MAAM;CAGhC","file":"measure.d.ts","sourcesContent":["/**\n * @packageDocumentation\n * @module ObnizCore.Components\n */\n\nimport Obniz from \"../../index\";\nimport { ComponentAbstract } from \"../ComponentAbstact\";\nimport ObnizUtil from \"../utils/util\";\nimport { LogicAnalyzerOptions } from \"./logicanalyzer\";\n\nexport interface ObnizMeasureResult {\n  edge: boolean;\n  timing: number;\n}\n\ntype ObnizMeasureResultArray = [ObnizMeasureResult, ObnizMeasureResult];\n\nexport interface ObnizMeasureOptions {\n  /**\n   * io number to generate pulse. Please use with 'pulse' and 'pulse_width' params.\n   *\n   * ![](media://measure_posneg.png)\n   *\n   * @category Pulse generation\n   *\n   */\n  io_pulse: number;\n\n  /**\n   * \"positive\" or \"negative\"\n   * @category Pulse generation\n   */\n  pulse: \"positive\" | \"negative\";\n\n  /**\n   * pulse duration in values between ms. 0.001 to 1000.\n   *\n   * @category Pulse generation\n   */\n  pulse_width: number;\n\n  /**\n   * io for measuring response. Please use with 'measure_edges' params.\n   * @category Response measurement\n   */\n  io_echo: number;\n\n  /**\n   * maximum number of edges to detect. 1 to 4.\n   * @category Response measurement\n   */\n  measure_edges: number;\n\n  /**\n   * timeout in ms, and default is 1000. 0.001 to 1000.\n   * @category Response measurement\n   */\n  timeout?: number;\n\n  /**\n   * callback function after measurement or timeout.\n   *\n   * A callback function will be called when the edge count = measure_edges or timeout.\n   * It has an array of edge information. For example, if you get a response like below\n   *\n   * ![](media://measure_response.png)\n   *\n   * then, you will get below\n   *\n   * ```javascript\n   * callback: function(edges) {\n   *   edges.length // == 2\n   *   edges[0].edge // == true\n   *   edges[0].timing // == t1\n   *   edges[1].edge // == false\n   *   edges[1].timing // == t2\n   * }\n   * ```\n   *\n   * @category Response measurement\n   */\n  callback?: (edges: ObnizMeasureResultArray) => void;\n}\n\n/**\n * The measure module provides hardware level measurement.\n * @category Measurement\n */\nexport default class ObnizMeasure extends ComponentAbstract {\n  private observers!: Array<(edges: ObnizMeasureResultArray) => void>;\n  private params?: ObnizMeasureOptions;\n\n  constructor(obniz: Obniz) {\n    super(obniz);\n    this._reset();\n  }\n\n  /**\n   * @ignore\n   * @private\n   */\n  public _reset() {\n    this.observers = [];\n  }\n\n  /**\n   * Some electrical parts or circuits accept \"pulse\" and echo the \"pulse\" after delay.\n   * This module is best suited for measuring that delay.\n   *\n   * This module generates one pulse shot on an io, then measures the response time.\n   *\n   *\n   * ```javascript\n   * // Javascript Example\n   * obniz.measure.echo({\n   *   io_pulse: 0, // io for generate pulse\n   *   io_echo: 1, // io to be measured\n   *   pulse: \"positive\", // generate pulse pattern\n   *   pulse_width: 0.1,  // generate pulse width\n   *   measure_edges: 3, // 1 to 4. maximum edges to measure\n   *   timeout: 1000, // this is optional. 1000(1sec) is default\n   *   callback: function(edges) {\n   *     // callback function\n   *     console.log(edges);\n   *   }\n   * });\n   * ```\n   *\n   * @param params\n   */\n  public echo(params: ObnizMeasureOptions) {\n    const err: any = ObnizUtil._requiredKeys(params, [\"io_pulse\", \"pulse\", \"pulse_width\", \"io_echo\", \"measure_edges\"]);\n    if (err) {\n      throw new Error(\"Measure start param '\" + err + \"' required, but not found \");\n    }\n    params = ObnizUtil._keyFilter(params, [\n      \"io_pulse\",\n      \"pulse\",\n      \"pulse_width\",\n      \"io_echo\",\n      \"measure_edges\",\n      \"timeout\",\n      \"callback\",\n    ]) as ObnizMeasureOptions;\n\n    const echo: any = {};\n    echo.io_pulse = params.io_pulse;\n    echo.pulse = params.pulse;\n    echo.pulse_width = params.pulse_width;\n    echo.io_echo = params.io_echo;\n    echo.measure_edges = params.measure_edges;\n    if (typeof params.timeout === \"number\") {\n      echo.timeout = params.timeout;\n    }\n\n    if (typeof params.callback === \"function\") {\n      this.onceQueue(\"/response/measure/echo\", (obj) => {\n        this.Obniz._runUserCreatedFunction(params.callback, obj.echo);\n      });\n    }\n\n    this.Obniz.send({\n      measure: {\n        echo,\n      },\n    });\n  }\n\n  public schemaBasePath(): string {\n    return \"measure\";\n  }\n}\n"]}