{"version":3,"sources":["../src/obniz/libs/measurements/measure.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;AAGH,0DAAwD;AACxD,yDAAsC;AA6EtC;;;GAGG;AACH,MAAqB,YAAa,SAAQ,oCAAiB;IAIzD,YAAY,KAAY;QACtB,KAAK,CAAC,KAAK,CAAC,CAAC;QACb,IAAI,CAAC,MAAM,EAAE,CAAC;IAChB,CAAC;IAED;;;OAGG;IACI,MAAM;QACX,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;IACtB,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;OAwBG;IACI,IAAI,CAAC,MAA2B;QACrC,MAAM,GAAG,GAAQ,cAAS,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,UAAU,EAAE,OAAO,EAAE,aAAa,EAAE,SAAS,EAAE,eAAe,CAAC,CAAC,CAAC;QACnH,IAAI,GAAG,EAAE;YACP,MAAM,IAAI,KAAK,CAAC,uBAAuB,GAAG,GAAG,GAAG,4BAA4B,CAAC,CAAC;SAC/E;QACD,MAAM,GAAG,cAAS,CAAC,UAAU,CAAC,MAAM,EAAE;YACpC,UAAU;YACV,OAAO;YACP,aAAa;YACb,SAAS;YACT,eAAe;YACf,SAAS;YACT,UAAU;SACX,CAAwB,CAAC;QAE1B,MAAM,IAAI,GAAQ,EAAE,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC;QAChC,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;QAC1B,IAAI,CAAC,WAAW,GAAG,MAAM,CAAC,WAAW,CAAC;QACtC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC;QAC9B,IAAI,CAAC,aAAa,GAAG,MAAM,CAAC,aAAa,CAAC;QAC1C,IAAI,OAAO,MAAM,CAAC,OAAO,KAAK,QAAQ,EAAE;YACtC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC;SAC/B;QAED,IAAI,OAAO,MAAM,CAAC,QAAQ,KAAK,UAAU,EAAE;YACzC,IAAI,CAAC,SAAS,CAAC,wBAAwB,EAAE,CAAC,GAAG,EAAE,EAAE;gBAC/C,IAAI,CAAC,KAAK,CAAC,uBAAuB,CAAC,MAAM,CAAC,QAAQ,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;YAChE,CAAC,CAAC,CAAC;SACJ;QAED,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;YACd,OAAO,EAAE;gBACP,IAAI;aACL;SACF,CAAC,CAAC;IACL,CAAC;IAEM,cAAc;QACnB,OAAO,SAAS,CAAC;IACnB,CAAC;CACF;AAnFD,+BAmFC","file":"measure.js","sourcesContent":["/**\n * @packageDocumentation\n * @module ObnizCore.Components\n */\n\nimport Obniz from \"../../index\";\nimport { ComponentAbstract } from \"../ComponentAbstact\";\nimport ObnizUtil from \"../utils/util\";\nimport { LogicAnalyzerOptions } from \"./logicanalyzer\";\n\nexport interface ObnizMeasureResult {\n  edge: boolean;\n  timing: number;\n}\n\ntype ObnizMeasureResultArray = [ObnizMeasureResult, ObnizMeasureResult];\n\nexport interface ObnizMeasureOptions {\n  /**\n   * io number to generate pulse. Please use with 'pulse' and 'pulse_width' params.\n   *\n   * ![](media://measure_posneg.png)\n   *\n   * @category Pulse generation\n   *\n   */\n  io_pulse: number;\n\n  /**\n   * \"positive\" or \"negative\"\n   * @category Pulse generation\n   */\n  pulse: \"positive\" | \"negative\";\n\n  /**\n   * pulse duration in values between ms. 0.001 to 1000.\n   *\n   * @category Pulse generation\n   */\n  pulse_width: number;\n\n  /**\n   * io for measuring response. Please use with 'measure_edges' params.\n   * @category Response measurement\n   */\n  io_echo: number;\n\n  /**\n   * maximum number of edges to detect. 1 to 4.\n   * @category Response measurement\n   */\n  measure_edges: number;\n\n  /**\n   * timeout in ms, and default is 1000. 0.001 to 1000.\n   * @category Response measurement\n   */\n  timeout?: number;\n\n  /**\n   * callback function after measurement or timeout.\n   *\n   * A callback function will be called when the edge count = measure_edges or timeout.\n   * It has an array of edge information. For example, if you get a response like below\n   *\n   * ![](media://measure_response.png)\n   *\n   * then, you will get below\n   *\n   * ```javascript\n   * callback: function(edges) {\n   *   edges.length // == 2\n   *   edges[0].edge // == true\n   *   edges[0].timing // == t1\n   *   edges[1].edge // == false\n   *   edges[1].timing // == t2\n   * }\n   * ```\n   *\n   * @category Response measurement\n   */\n  callback?: (edges: ObnizMeasureResultArray) => void;\n}\n\n/**\n * The measure module provides hardware level measurement.\n * @category Measurement\n */\nexport default class ObnizMeasure extends ComponentAbstract {\n  private observers!: Array<(edges: ObnizMeasureResultArray) => void>;\n  private params?: ObnizMeasureOptions;\n\n  constructor(obniz: Obniz) {\n    super(obniz);\n    this._reset();\n  }\n\n  /**\n   * @ignore\n   * @private\n   */\n  public _reset() {\n    this.observers = [];\n  }\n\n  /**\n   * Some electrical parts or circuits accept \"pulse\" and echo the \"pulse\" after delay.\n   * This module is best suited for measuring that delay.\n   *\n   * This module generates one pulse shot on an io, then measures the response time.\n   *\n   *\n   * ```javascript\n   * // Javascript Example\n   * obniz.measure.echo({\n   *   io_pulse: 0, // io for generate pulse\n   *   io_echo: 1, // io to be measured\n   *   pulse: \"positive\", // generate pulse pattern\n   *   pulse_width: 0.1,  // generate pulse width\n   *   measure_edges: 3, // 1 to 4. maximum edges to measure\n   *   timeout: 1000, // this is optional. 1000(1sec) is default\n   *   callback: function(edges) {\n   *     // callback function\n   *     console.log(edges);\n   *   }\n   * });\n   * ```\n   *\n   * @param params\n   */\n  public echo(params: ObnizMeasureOptions) {\n    const err: any = ObnizUtil._requiredKeys(params, [\"io_pulse\", \"pulse\", \"pulse_width\", \"io_echo\", \"measure_edges\"]);\n    if (err) {\n      throw new Error(\"Measure start param '\" + err + \"' required, but not found \");\n    }\n    params = ObnizUtil._keyFilter(params, [\n      \"io_pulse\",\n      \"pulse\",\n      \"pulse_width\",\n      \"io_echo\",\n      \"measure_edges\",\n      \"timeout\",\n      \"callback\",\n    ]) as ObnizMeasureOptions;\n\n    const echo: any = {};\n    echo.io_pulse = params.io_pulse;\n    echo.pulse = params.pulse;\n    echo.pulse_width = params.pulse_width;\n    echo.io_echo = params.io_echo;\n    echo.measure_edges = params.measure_edges;\n    if (typeof params.timeout === \"number\") {\n      echo.timeout = params.timeout;\n    }\n\n    if (typeof params.callback === \"function\") {\n      this.onceQueue(\"/response/measure/echo\", (obj) => {\n        this.Obniz._runUserCreatedFunction(params.callback, obj.echo);\n      });\n    }\n\n    this.Obniz.send({\n      measure: {\n        echo,\n      },\n    });\n  }\n\n  public schemaBasePath(): string {\n    return \"measure\";\n  }\n}\n"]}