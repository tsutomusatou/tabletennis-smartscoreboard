{"version":3,"sources":["../src/obniz/libs/io_peripherals/directive.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAGH,OAAO,KAAK,MAAM,aAAa,CAAC;AAChC,OAAO,EAAE,iBAAiB,EAAE,MAAM,qBAAqB,CAAC;AACxD,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAE3C,MAAM,WAAW,uBAAuB;IACtC;;OAEG;IACH,QAAQ,EAAE,MAAM,CAAC;IAEjB;;;OAGG;IACH,KAAK,EAAE,CAAC,KAAK,EAAE,MAAM,KAAK,IAAI,CAAC;CAChC;AAED;;GAEG;AACH,MAAM,CAAC,OAAO,OAAO,SAAU,SAAQ,iBAAiB;IACtD,OAAO,CAAC,SAAS,CAAa;IAC9B,OAAO,CAAC,oBAAoB,CAAa;gBAE7B,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,MAAM;IAiBpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAwDG;IACI,SAAS,CAAC,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,eAAe,EAAE,UAAU,CAAC,EAAE,uBAAuB,EAAE,EAAE,MAAM,CAAC,EAAE,MAAM;IAwC/G;;;;;;;;;;;;;;;;;;;;;;OAsBG;IACI,UAAU,CAAC,UAAU,EAAE,uBAAuB,EAAE,EAAE,MAAM,EAAE,MAAM;IAsBhE,cAAc,IAAI,MAAM;IAI/B;;;OAGG;IACH,SAAS,CAAC,MAAM;IAUhB,OAAO,CAAC,WAAW;CASpB","file":"directive.d.ts","sourcesContent":["/**\n * @packageDocumentation\n * @module ObnizCore.Components\n */\n\nimport semver from \"semver\";\nimport Obniz from \"../../index\";\nimport { ComponentAbstract } from \"../ComponentAbstact\";\nimport { AnimationStatus } from \"./common\";\n\nexport interface DirectiveAnimationFrame {\n  /**\n   * frame duration time in milliseconds\n   */\n  duration: number;\n\n  /**\n   * function of frame io config\n   * @param state.index frame index\n   */\n  state: (index: number) => void;\n}\n\n/**\n * @category Peripherals\n */\nexport default class Directive extends ComponentAbstract {\n  private observers: any[] = [];\n  private _animationIdentifier: number = 0;\n\n  constructor(obniz: Obniz, id: number) {\n    super(obniz);\n\n    this.on(\"/response/ioAnimation/notify\", (obj) => {\n      if (obj.animation.status === \"finish\") {\n        for (let i = this.observers.length - 1; i >= 0; i--) {\n          if (obj.animation.name === this.observers[i].name) {\n            this.observers[i].resolve();\n            this.observers.splice(i, 1);\n          }\n        }\n      }\n    });\n\n    this._reset();\n  }\n\n  /**\n   * io animation is used when you wish to accelerate the serial sequence change of io.\n   *\n   * \"Loop\" animation can be used.\n   * io changes repeatedly in a sequential manner according to json array.\n   * io and pwm json commands can only be used.\n   *\n   *\n   * obnizOS ver >= 2.0.0 required.\n   *\n   * ```javascript\n   * //javascript\n   * // Javascript Example\n   * obniz.io.animation(\"animation-1\", \"loop\", [\n   *  {\n   *   duration: 10,\n   *   state: function(index){ // index = 0\n   *     obniz.io0.output(false)\n   *     obniz.io1.output(true)\n   *   }\n   *  },{\n   *    duration: 10,\n   *    state: function(index){ // index = 1\n   *      obniz.io0.output(true)\n   *      obniz.io1.output(false)\n   *    }\n   *  }\n   * ])\n   * ```\n   *\n   * It will generate signals likes below\n   *\n   *  ![](media://ioanimation.png)\n   *\n   * - Remove animation\n   *\n   * ```javascript\n   * obniz.io.animation(\"animation-1\", \"loop\")\n   * ```\n   *\n   * - Pause animation\n   *\n   * ```javascript\n   * obniz.io.animation(\"animation-1\", \"pause\")\n   * ```\n   *\n   * - Resume paused animation\n   *\n   * ```javascript\n   * obniz.io.animation(\"animation-1\", \"resume\")\n   * ```\n   *\n   * @param name name of animation\n   * @param status status of animation\n   * @param animations instructions. This is optional when status is pause``resume.\n   * @param repeat The number of repeat count of animation. If not specified, it repeat endless.\n   */\n  public animation(name: string, status: AnimationStatus, animations?: DirectiveAnimationFrame[], repeat?: number) {\n    if ((typeof repeat === \"number\" || status === \"registrate\") && semver.lt(this.Obniz.firmware_ver!, \"2.0.0\")) {\n      throw new Error(`Please update obniz firmware >= 2.0.0`);\n    }\n    const obj: any = {};\n    obj.io = {\n      animation: {\n        name,\n        status,\n      },\n    };\n    if (typeof repeat === \"number\") {\n      obj.io.animation.repeat = repeat;\n    }\n    if (!animations) {\n      animations = [];\n    }\n\n    const states: any[] = [];\n    for (let i = 0; i < animations.length; i++) {\n      const state: any = animations[i];\n      const duration: number = state.duration;\n      const operation: (index: number) => {} = state.state;\n\n      // dry run. and get json commands\n      (this.Obniz as any).sendPool = [];\n      operation(i);\n      const pooledJsonArray: any = (this.Obniz as any).sendPool;\n      (this.Obniz as any).sendPool = null;\n      states.push({\n        duration,\n        state: pooledJsonArray,\n      });\n    }\n    if (status === \"loop\" || status === \"registrate\") {\n      obj.io.animation.states = states;\n    }\n    this.Obniz.send(obj);\n  }\n\n  /**\n   * It start io aniomation with limited repeat count. And It wait until done.\n   *\n   * ```javascript\n   * // Javascript Example\n   * await obniz.io.repeatWait([\n   *   {\n   *     duration: 1000,\n   *     state: function(index){\n   *       obniz.io0.output(true)\n   *     }\n   *   },{\n   *     duration: 1000,\n   *     state: function(index){\n   *       obniz.io0.output(false)\n   *    }\n   *   }\n   * ], 4)\n   * ```\n   *\n   * @param animations instructions\n   * @param repeat  The number of repeat count of animation.\n   */\n  public repeatWait(animations: DirectiveAnimationFrame[], repeat: number) {\n    if (semver.lt(this.Obniz.firmware_ver!, \"2.0.0\")) {\n      throw new Error(`Please update obniz firmware >= 2.0.0`);\n    }\n    if (typeof repeat !== \"number\" || repeat < 1) {\n      throw new Error(\"please specify repeat count > 0\");\n    }\n    if (Math.floor(repeat) !== repeat) {\n      throw new Error(\"please provide integer number like 1, 2, 3,,,\");\n    }\n\n    return new Promise((resolve: any, reject: any) => {\n      const name = \"_repeatwait\" + Date.now() + this._animationIdentifier;\n      if (++this._animationIdentifier > 1000) {\n        this._animationIdentifier = 0;\n      }\n\n      this.animation(name, \"loop\", animations, repeat);\n      this.addObserver(name, resolve, reject);\n    });\n  }\n\n  public schemaBasePath(): string {\n    return \"io\";\n  }\n\n  /**\n   * @ignore\n   * @private\n   */\n  protected _reset() {\n    if (this.observers) {\n      for (let i = 0; i < this.observers.length; i++) {\n        this.observers[i].reject(new Error(\"reset called\"));\n      }\n    }\n    this.observers = [];\n    this._animationIdentifier = 0;\n  }\n\n  private addObserver(name: string, resolve: any, reject: any) {\n    if (name && resolve && reject) {\n      this.observers.push({\n        name,\n        resolve,\n        reject,\n      });\n    }\n  }\n}\n"]}