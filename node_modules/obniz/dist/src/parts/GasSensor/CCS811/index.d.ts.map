{"version":3,"sources":["../src/parts/GasSensor/CCS811/index.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,KAAK,MAAM,gBAAgB,CAAC;AACnC,OAAO,EAAE,QAAQ,EAAE,MAAM,2CAA2C,CAAC;AACrE,OAAO,YAAY,MAAM,uCAAuC,CAAC;AACjE,OAAO,mBAAmB,EAAE,EAAE,cAAc,EAAE,MAAM,oCAAoC,CAAC;AACzF,OAAO,QAAQ,EAAE,EAAE,OAAO,EAAE,uBAAuB,EAAE,MAAM,gBAAgB,CAAC;AAE5E,MAAM,WAAW,aAAc,SAAQ,uBAAuB;IAC5D,IAAI,CAAC,EAAE,QAAQ,CAAC;IAChB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,OAAO,CAAC,EAAE,MAAM,CAAC;CAClB;AAED,MAAM,CAAC,OAAO,OAAO,MAAO,SAAQ,QAAS,YAAW,mBAAmB;WAC3D,IAAI,IAAI,cAAc;IAM7B,OAAO,EAAE,OAAO,CAAC;IACjB,IAAI,EAAE,MAAM,EAAE,CAAC;IACf,YAAY,EAAE,MAAM,EAAE,CAAC;IACvB,MAAM,CAAC,EAAE,MAAM,EAAE,GAAG,SAAS,CAAC;IAC9B,MAAM,EAAE,GAAG,CAAC;IACZ,QAAQ,EAAE,GAAG,CAAC;IACd,MAAM,CAAC,EAAE,YAAY,CAAC;IACtB,OAAO,CAAC,EAAE,YAAY,CAAC;IACvB,OAAO,CAAC,EAAE,YAAY,CAAC;;IAkCvB,OAAO;IAIP,KAAK,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI;IAkCnB,UAAU;IAwBhB,KAAK;IASC,gBAAgB,CAAC,IAAI,EAAE,MAAM;IAU7B,eAAe,IAAI,OAAO,CAAC,MAAM,CAAC;IAIlC,gBAAgB,IAAI,OAAO,CAAC,MAAM,CAAC;IASnC,wBAAwB,CAAC,gBAAgB,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAuBtF,sBAAsB,IAAI,OAAO,CAAC,OAAO,CAAC;IAK1C,wBAAwB,IAAI,OAAO,CAAC;QAAE,IAAI,EAAE,MAAM,CAAC;QAAC,IAAI,EAAE,MAAM,CAAA;KAAE,CAAC;IASnE,WAAW,IAAI,OAAO,CAAC,MAAM,CAAC;IAG9B,WAAW,IAAI,OAAO,CAAC,MAAM,CAAC;IAIpC,IAAI,IAAI,IAAI;IAMZ,KAAK,IAAI,IAAI;IAMP,WAAW,IAAI,OAAO,CAAC,IAAI,CAAC;CAO1C","file":"index.d.ts","sourcesContent":["/**\n * @packageDocumentation\n * @module Parts.CCS811\n */\n\nimport Obniz from \"../../../obniz\";\nimport { PullType } from \"../../../obniz/libs/io_peripherals/common\";\nimport PeripheralIO from \"../../../obniz/libs/io_peripherals/io\";\nimport ObnizPartsInterface, { ObnizPartsInfo } from \"../../../obniz/ObnizPartsInterface\";\nimport i2cParts, { I2cInfo, I2cPartsAbstractOptions } from \"../../i2cParts\";\n\nexport interface CCS811Options extends I2cPartsAbstractOptions {\n  pull?: PullType;\n  nwak?: number;\n  nrst?: number;\n  nint?: number;\n  add?: number;\n  address?: number;\n}\n\nexport default class CCS811 extends i2cParts implements ObnizPartsInterface {\n  public static info(): ObnizPartsInfo {\n    return {\n      name: \"CCS811\",\n      // datasheet: \"\",\n    };\n  }\n  public i2cinfo: I2cInfo;\n  public keys: string[];\n  public requiredKeys: string[];\n  public ioKeys?: string[] | undefined;\n  public params: any;\n  public commands: any;\n  public io_add?: PeripheralIO;\n  public io_nwak?: PeripheralIO;\n  public io_nrst?: PeripheralIO;\n\n  constructor() {\n    super();\n    this.i2cinfo = {\n      address: 0x5b,\n      clock: 100000,\n      voltage: \"3v\",\n      pull: \"3v\",\n    };\n    this.requiredKeys = [];\n    this.keys = [\"vcc\", \"gnd\", \"scl\", \"sda\", \"nwak\", \"nrst\", \"nint\", \"i2c\", \"add\", \"address\"];\n    this.ioKeys = [\"vcc\", \"gnd\", \"scl\", \"sda\", \"nwak\", \"nrst\", \"nint\", \"add\"];\n\n    this.commands = {};\n    this.commands.addresses = {\n      CCS811_STATUS: 0x00,\n      CCS811_MEAS_MODE: 0x01,\n      CCS811_ALG_RESULT_DATA: 0x02,\n      CCS811_RAW_DATA: 0x03,\n      CCS811_ENV_DATA: 0x05,\n      CCS811_NTC: 0x06,\n      CCS811_THRESHOLDS: 0x10,\n      CCS811_BASELINE: 0x11,\n      CCS811_HW_ID: 0x20,\n      CCS811_HW_VERSION: 0x21,\n      CCS811_FW_BOOT_VERSION: 0x23,\n      CCS811_FW_APP_VERSION: 0x24,\n      CCS811_ERROR_ID: 0xe0,\n      CCS811_APP_START: 0xf4,\n      CCS811_SW_RESET: 0xff,\n    };\n  }\n\n  public i2cInfo() {\n    return this.i2cinfo;\n  }\n\n  public wired(obniz: Obniz): void {\n    this.obniz = obniz;\n\n    this.obniz.setVccGnd(this.params.vcc, null, \"3v\");\n    this.obniz.setVccGnd(null, this.params.gnd, \"5v\");\n    this.obniz.wait(10);\n\n    this.address = 0x5b;\n    if (this.params.address === 0x5b) {\n      this.address = 0x5b;\n    } else if (this.params.address === 0x5a) {\n      this.address = 0x5a;\n    } else if (this.params.address !== undefined) {\n      throw new Error(\"address must be 0x5a or 0x5b\");\n    }\n\n    if (obniz.isValidIO(this.params.add)) {\n      this.io_add = obniz.getIO(this.params.add);\n      this.io_add.drive(\"3v\");\n      this.io_add.output(this.address === 0x5a ? false : true);\n    }\n\n    if (this.params.i2c !== undefined) {\n      this.i2c = this.params.i2c;\n    } else {\n      this.params.clock = this.params.clock || 100 * 1000;\n      this.params.mode = \"master\";\n      this.params.pull = \"3v\";\n      this.i2c = obniz.getI2CWithConfig(this.params);\n    }\n\n    this.obniz.wait(10);\n  }\n\n  public async configWait() {\n    // restart\n    const readCheck = await this.readWait(this.commands.addresses.CCS811_HW_ID, 1);\n    if (readCheck[0] !== 0x81) {\n      console.log(\"readCheck error \" + readCheck);\n    }\n    await this.obniz.wait(10);\n    console.log(\"restarted\");\n\n    // reset\n    this.write(this.commands.addresses.CCS811_SW_RESET, [0x11, 0xe5, 0x72, 0x8a]);\n    await this.obniz.wait(10);\n    console.log(\"reset\");\n\n    // checkForStatusError\n    const status = await this.readWait(this.commands.addresses.CCS811_STATUS, 1);\n    console.log(\"Status: \" + status);\n\n    this.start();\n    await this.setDriveModeWait(1); // Read every second\n    await this.obniz.wait(10);\n    console.log(\"config done\");\n  }\n\n  public start() {\n    this.write(this.commands.addresses.CCS811_APP_START, []);\n  }\n\n  // Mode 0 = Idle\n  // Mode 1 = read every 1s\n  // Mode 2 = every 10s\n  // Mode 3 = every 60s\n  // Mode 4 = RAW mode\n  public async setDriveModeWait(mode: number) {\n    if (mode > 4) {\n      mode = 4;\n    } // sanitize input\n    let value: number = await this.getMeasModeWait();\n    value &= ~(0b00000111 << 4); // Clear DRIVE_MODE bits\n    value |= mode << 4; // Mask in mode\n    this.write(this.commands.addresses.CCS811_MEAS_MODE, value);\n  }\n\n  public async getMeasModeWait(): Promise<number> {\n    const meas_mode = await this.readWait(this.commands.addresses.CCS811_MEAS_MODE, 1); // Read what's currently there\n    return meas_mode[0];\n  }\n  public async getDriveModeWait(): Promise<number> {\n    const meas_mode: number = await this.getMeasModeWait();\n    let drive_mode = meas_mode >>> 4;\n    if (drive_mode > 8) {\n      drive_mode -= 8;\n    }\n    return drive_mode;\n  }\n\n  public async setEnvironmentalDataWait(relativeHumidity: number, temperature: number): Promise<void> {\n    // Check for invalid temperatures\n    if (temperature < -25 || temperature > 50) {\n      console.log(\"temperature is out of range\");\n    }\n    // Check for invalid humidity\n    if (relativeHumidity < 0 || relativeHumidity > 100) {\n      console.log(\"humidity is out of range\");\n    }\n\n    const rH = relativeHumidity * 1000; // 42.348 becomes 42348\n    let temp = temperature * 1000; // 23.2 becomes 23200\n    const envData = [];\n    envData[0] = Math.round((rH + 250) / 500);\n    envData[1] = 0; // CCS811 only supports increments of 0.5 so bits 7-0 will always be zero\n    temp += 25000; // Add the 25C offset\n    envData[2] = Math.round((temp + 250) / 500);\n    envData[3] = 0;\n    // console.log(\"envData: \", envData);\n    this.write(this.commands.addresses.CCS811_ENV_DATA, envData);\n  }\n\n  // Checks to see if DATA_READ flag is set in the status register\n  public async checkAvailableDataWait(): Promise<boolean> {\n    const value = (await this.readWait(this.commands.addresses.CCS811_STATUS, 1))[0];\n    return Boolean(value & (1 << 3));\n  }\n\n  public async readAlgorithmResultsWait(): Promise<{ eCO2: number; TVOC: number }> {\n    const data = await this.readWait(this.commands.addresses.CCS811_ALG_RESULT_DATA, 8);\n    // Data ordered:\n    // co2MSB, co2LSB, tvocMSB, tvocLSB\n    const eCO2 = (data[0] << 8) | data[1];\n    const TVOC = (data[2] << 8) | data[3];\n    return { eCO2, TVOC };\n  }\n\n  public async geteCO2Wait(): Promise<number> {\n    return (await this.readAlgorithmResultsWait()).eCO2;\n  }\n  public async getTVOCWait(): Promise<number> {\n    return (await this.readAlgorithmResultsWait()).TVOC;\n  }\n\n  public wake(): void {\n    this.io_nwak = this.obniz.getIO(this.params.nwak);\n    this.io_nwak.drive(\"3v\");\n    this.io_nwak.output(false);\n  }\n\n  public sleep(): void {\n    this.io_nwak = this.obniz.getIO(this.params.nwak);\n    this.io_nwak.drive(\"3v\");\n    this.io_nwak.output(true);\n  }\n\n  public async hwResetWait(): Promise<void> {\n    this.io_nrst = this.obniz.getIO(this.params.nrst);\n    this.io_nrst.drive(\"3v\");\n    this.io_nrst.output(false);\n    await this.obniz.wait(10);\n    this.io_nrst.output(true);\n  }\n}\n"]}