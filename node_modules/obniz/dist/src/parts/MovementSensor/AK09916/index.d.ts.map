{"version":3,"sources":["../src/parts/MovementSensor/AK09916/index.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,QAAQ,EAAE,EAAE,OAAO,EAAE,uBAAuB,EAAE,MAAM,gBAAgB,CAAC;AAE5E,OAAO,KAAK,MAAM,gBAAgB,CAAC;AAEnC,OAAO,mBAAmB,EAAE,EAAE,cAAc,EAAE,MAAM,oCAAoC,CAAC;AAEzF,MAAM,WAAW,cAAe,SAAQ,uBAAuB;CAAG;AAElE,MAAM,CAAC,OAAO,OAAO,OAAQ,SAAQ,QAAS,YAAW,mBAAmB;WAC5D,IAAI,IAAI,cAAc;IAM7B,OAAO,EAAE,OAAO,CAKrB;IAEF,SAAS,CAAC,KAAK,EAAG,KAAK,CAAC;IAExB,OAAO,CAAC,IAAI,CAAQ;IAEpB,OAAO,CAAC,IAAI,CAAQ;IACpB,OAAO,CAAC,IAAI,CAAQ;IACpB,OAAO,CAAC,IAAI,CAAQ;IACpB,OAAO,CAAC,IAAI,CAAQ;IACpB,OAAO,CAAC,IAAI,CAAQ;IACpB,OAAO,CAAC,IAAI,CAAQ;IACpB,OAAO,CAAC,IAAI,CAAQ;IACpB,OAAO,CAAC,IAAI,CAAQ;IACpB,OAAO,CAAC,MAAM,CAAQ;IACtB,OAAO,CAAC,KAAK,CAAQ;IACrB,OAAO,CAAC,KAAK,CAAQ;IACrB,OAAO,CAAC,KAAK,CAAQ;IAErB,OAAO,CAAC,gBAAgB,CAAc;IACtC,OAAO,CAAC,mBAAmB,CAAc;IACzC,OAAO,CAAC,wBAAwB,CAAc;IAC9C,OAAO,CAAC,wBAAwB,CAAc;IAC9C,OAAO,CAAC,6BAA6B,CAAc;IACnD,OAAO,CAAC,eAAe,CAAc;IACrC,OAAO,CAAC,qBAAqB,CAAc;IAE3C,OAAO,CAAC,aAAa,CAAc;IACnC,OAAO,CAAC,aAAa,CAAc;IAEnC,OAAO,CAAC,SAAS,CAAO;IACxB,OAAO,CAAC,SAAS,CAAQ;IAEzB,OAAO,CAAC,EAAE,CAAS;IAEnB,OAAO,CAAC,MAAM,CAA2B;IACzC,OAAO,CAAC,KAAK,CAA2B;;IASjC,KAAK,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI;IAKnB,QAAQ,IAAI,OAAO,CAAC,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IAgB7C,UAAU,IAAI,OAAO,CAAC,MAAM,CAAC;IAK7B,aAAa,CAAC,KAAK,GAAE,MAAY,EAAE,KAAK,GAAE,MAAY;;;;CA+CpE","file":"index.d.ts","sourcesContent":["/**\n * @packageDocumentation\n * @module Parts.AK09916\n */\n\nimport i2cParts, { I2cInfo, I2cPartsAbstractOptions } from \"../../i2cParts\";\n\nimport Obniz from \"../../../obniz\";\nimport { DriveType, PullType } from \"../../../obniz/libs/io_peripherals/common\";\nimport ObnizPartsInterface, { ObnizPartsInfo } from \"../../../obniz/ObnizPartsInterface\";\n\nexport interface AK09916Options extends I2cPartsAbstractOptions {}\n\nexport default class AK09916 extends i2cParts implements ObnizPartsInterface {\n  public static info(): ObnizPartsInfo {\n    return {\n      name: \"AK09916\",\n    };\n  }\n\n  public i2cinfo: I2cInfo = {\n    address: 0x0c,\n    clock: 100000,\n    voltage: \"3v\",\n    pull: \"3v\",\n  };\n\n  protected obniz!: Obniz;\n\n  private ADDR = 0x0c;\n\n  private _WIA = 0x01;\n  private _HXL = 0x11;\n  private _HXH = 0x12;\n  private _HYL = 0x13;\n  private _HYH = 0x14;\n  private _HZL = 0x15;\n  private _HZH = 0x16;\n  private _ST2 = 0x18;\n  private _CNTL2 = 0x31;\n  private _ASAX = 0x60;\n  private _ASAY = 0x61;\n  private _ASAZ = 0x62;\n\n  private _MODE_POWER_DOWN = 0b00000000;\n  private MODE_SINGLE_MEASURE = 0b00000001;\n  private MODE_CONTINOUS_MEASURE_1 = 0b00000010; // 10Hz\n  private MODE_CONTINOUS_MEASURE_2 = 0b00001000; // 100Hz\n  private MODE_EXTERNAL_TRIGGER_MEASURE = 0b00000100;\n  private _MODE_SELF_TEST = 0b00001000;\n  private _MODE_FUSE_ROM_ACCESS = 0b00011111;\n\n  private OUTPUT_14_BIT = 0b00000000;\n  private OUTPUT_16_BIT = 0b00010000;\n\n  private _SO_14BIT = 0.6; // per digit when 14bit mode\n  private _SO_16BIT = 0.15; //  per digit when 16bit mode\n\n  private so: number;\n\n  private offset: [number, number, number];\n  private scale: [number, number, number];\n\n  constructor() {\n    super();\n    this.offset = [0, 0, 0];\n    this.scale = [1, 1, 1];\n    this.so = this._SO_16BIT;\n  }\n\n  public wired(obniz: Obniz): void {\n    super.wired(obniz);\n    this.write(this._CNTL2, this.MODE_CONTINOUS_MEASURE_1);\n  }\n\n  public async magnetic(): Promise<[number, number, number]> {\n    // 0111 1111 1111 0000 4912 uT\n    // 1111 1111 1111 1111 -1 uT\n    // 1000 0000 0001 0000 -4912 uT\n    // data[0]下位ビット data[1] 上位ビット\n\n    const raw3: [number, number, number] = await this.readThreeInt16Wait(this._HXL, \"l\");\n\n    this.readWait(this._ST2, 1);\n\n    const xyz: [number, number, number] = raw3.map((d, i) => {\n      return (d * this.so - this.offset[i]) * this.scale[i];\n    }) as [number, number, number];\n    return xyz;\n  }\n\n  public async whoamiWait(): Promise<number> {\n    const result = await this.readWait(this._WIA, 1);\n    return result[0];\n  }\n\n  public async calibrateWait(count: number = 256, delay: number = 200) {\n    this.offset = [0, 0, 0];\n    this.scale = [1, 1, 1];\n\n    let reading = await this.magnetic();\n    let minx = reading[0];\n    let maxx = reading[0];\n    let miny = reading[1];\n    let maxy = reading[1];\n    let minz = reading[2];\n    let maxz = reading[2];\n\n    while (count > 0) {\n      await new Promise((r) => setTimeout(r, delay));\n\n      reading = await this.magnetic();\n      minx = Math.min(minx, reading[0]);\n      maxx = Math.max(maxx, reading[0]);\n      miny = Math.min(miny, reading[1]);\n      maxy = Math.max(maxy, reading[1]);\n      minz = Math.min(minz, reading[2]);\n      maxz = Math.max(maxz, reading[2]);\n      count -= 1;\n    }\n\n    // Hard iron correction\n    const offset_x = (maxx + minx) / 2;\n    const offset_y = (maxy + miny) / 2;\n    const offset_z = (maxz + minz) / 2;\n\n    this.offset = [offset_x, offset_y, offset_z];\n\n    // Soft iron correction\n    const avg_delta_x = (maxx - minx) / 2;\n    const avg_delta_y = (maxy - miny) / 2;\n    const avg_delta_z = (maxz - minz) / 2;\n\n    const avg_delta = (avg_delta_x + avg_delta_y + avg_delta_z) / 3;\n\n    const scale_x = avg_delta / avg_delta_x;\n    const scale_y = avg_delta / avg_delta_y;\n    const scale_z = avg_delta / avg_delta_z;\n\n    this.scale = [scale_x, scale_y, scale_z];\n\n    return { offset: this.offset, scale: this.scale };\n  }\n}\n"]}