{"version":3,"sources":["../src/parts/MovementSensor/MPU6050/index.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,KAAK,MAAM,gBAAgB,CAAC;AACnC,OAAO,EAAE,cAAc,EAAE,MAAM,oCAAoC,CAAC;AACpE,OAAO,OAAO,EAAE,EAAE,UAAU,EAAE,SAAS,EAAE,sBAAsB,EAAE,QAAQ,EAAE,GAAG,EAAE,MAAM,eAAe,CAAC;AACtG,OAAO,EAAE,OAAO,EAAE,MAAM,gBAAgB,CAAC;AAEzC,MAAM,WAAW,cAAe,SAAQ,sBAAsB;CAAG;AAEjE,MAAM,CAAC,OAAO,OAAO,OAAQ,SAAQ,OAAO;WAC5B,IAAI,IAAI,cAAc;IAMpC,SAAS,CAAC,MAAM,CAAC,QAAQ,EAAE,GAAG,CAuC5B;IAEK,OAAO,EAAE,OAAO,CAAC;;IAYjB,QAAQ,CAAC,IAAI,CAAC,EAAE,MAAM,GAAG,IAAI,GAAG,MAAM,GAAG,IAAI;IAO7C,KAAK,CAAC,KAAK,EAAE,KAAK;IAKlB,IAAI;IAwBE,SAAS;IAIT,QAAQ;IAIR,SAAS;IAIT,cAAc;IAEd,sBAAsB,CAAC,IAAI,GAAE,OAAc,GAAG,OAAO,CAAC,IAAI,CAAC;IAa3D,UAAU,IAAI,OAAO,CAAC,MAAM,CAAC;IAK7B,eAAe,IAAI,OAAO,CAAC,GAAG,CAAC;IAK/B,cAAc,IAAI,OAAO,CAAC,GAAG,CAAC;IAK9B,cAAc,IAAI,OAAO,CAAC,MAAM,CAAC;IAKjC,aAAa,IAAI,OAAO,CAAC,QAAQ,CAAC;IASxC,aAAa,CAAC,WAAW,EAAE,UAAU,GAAG,IAAI;IAS5C,YAAY,CAAC,UAAU,EAAE,SAAS,GAAG,IAAI;IASzC,SAAS,CAAC,mBAAmB,EAAE,MAAM,EAAE,eAAe,EAAE,MAAM,EAAE,SAAS,CAAC,EAAE,GAAG;CAoCvF","file":"index.d.ts","sourcesContent":["/**\n * @packageDocumentation\n * @module Parts.MPU6050\n */\n\nimport Obniz from \"../../../obniz\";\nimport { ObnizPartsInfo } from \"../../../obniz/ObnizPartsInterface\";\nimport I2cImu6, { accelRange, gyroRange, I2cImu6AbstractOptions, Inertia6, Xyz } from \"../../i2cImu6\";\nimport { I2cInfo } from \"../../i2cParts\";\n\nexport interface MPU6050Options extends I2cImu6AbstractOptions {}\n\nexport default class MPU6050 extends I2cImu6 {\n  public static info(): ObnizPartsInfo {\n    return {\n      name: \"MPU6050\",\n    };\n  }\n\n  protected static commands: any = {\n    whoami: 0x75,\n    whoami_result: 0x71,\n    pwr_mgmt_1: 0x6b,\n    pwr_mgmt_2: 0x6c,\n    smplrt_div: 0x19,\n    int_pin_cfg: 0x37,\n    int_enable: 0x38,\n    user_ctrl: 0x6a,\n    config: 0x1a,\n    fifo_en: 0x23,\n    accel_x_h: 0x3b,\n    accel_x_l: 0x3c,\n    accel_y_h: 0x3d,\n    accel_y_l: 0x3e,\n    accel_z_h: 0x3f,\n    accel_z_l: 0x40,\n    temp_h: 0x41,\n    temp_l: 0x42,\n    gyro_x_h: 0x43,\n    gyro_x_l: 0x44,\n    gyro_y_h: 0x45,\n    gyro_y_l: 0x46,\n    gyro_z_h: 0x47,\n    gyro_z_l: 0x48,\n    gyro_config: 0x1b,\n    accel_config: 0x1c,\n    accel_fs_sel: {\n      \"2g\": 0x00,\n      \"4g\": 0x08,\n      \"8g\": 0x10,\n      \"16g\": 0x18,\n    },\n    gyro_fs_sel: {\n      \"250dps\": 0x00,\n      \"500dps\": 0x08,\n      \"1000dps\": 0x10,\n      \"2000dps\": 0x18,\n    },\n  };\n\n  public i2cinfo: I2cInfo;\n\n  constructor() {\n    super();\n    this.i2cinfo = {\n      address: 0x68,\n      clock: 100000,\n      voltage: \"3v\",\n      pull: \"3v\",\n    };\n  }\n\n  public calcTemp(data?: number | null): number | null {\n    if (typeof data === \"undefined\" || data === null) {\n      return null;\n    }\n    return data / 333.87 + 21;\n  }\n\n  public wired(obniz: Obniz) {\n    super.wired(obniz);\n    this.init();\n  }\n\n  public init() {\n    this.write(MPU6050.commands.pwr_mgmt_1, 0x00);\n    this.obniz.wait(10);\n    // set dlpf\n    this.obniz.wait(1);\n    this.write(MPU6050.commands.config, 0x01);\n    // set samplerate div\n    this.obniz.wait(1);\n    this.write(MPU6050.commands.smplrt_div, 0x05);\n    // interrupt enable\n    this.obniz.wait(1);\n    this.write(MPU6050.commands.int_enable, 0x00);\n    this.obniz.wait(1);\n    this.write(MPU6050.commands.user_ctrl, 0x00);\n    this.obniz.wait(1);\n    this.write(MPU6050.commands.fifo_en, 0x00);\n    this.obniz.wait(1);\n    this.write(MPU6050.commands.int_pin_cfg, 0x22);\n    this.obniz.wait(1);\n    this.write(MPU6050.commands.int_enable, 0x01);\n    this.obniz.wait(1);\n    this.setConfig(2, 250);\n  }\n\n  public async sleepWait() {\n    await this.writeFlagWait(MPU6050.commands.pwr_mgmt_1, 6);\n  }\n\n  public async wakeWait() {\n    await this.clearFlagWait(MPU6050.commands.pwr_mgmt_1, 6);\n  }\n\n  public async resetWait() {\n    await this.writeFlagWait(MPU6050.commands.pwr_mgmt_1, 7);\n  }\n\n  public async configDlpfWait() {}\n\n  public async bypassMagnetometerWait(flag: boolean = true): Promise<void> {\n    // Enable I2C bypass to access for MPU9250 magnetometer access.\n    if (flag === true) {\n      await this.writeFlagWait(MPU6050.commands.int_pin_cfg, 1);\n    } else {\n      await this.clearFlagWait(MPU6050.commands.int_pin_cfg, 1);\n    }\n    // this.i2c.write(this.address, [MPU6050.commands.int_pin_cfg]);\n    // const data =  await this.i2c!.readWait(this.address, 1);\n    // data[0] |= MPU6050.commands.intPinConfigMask.bypass_en;\n    // this.i2c.write(this.address, [MPU6050.commands.int_pin_cfg, data[0]]);\n  }\n\n  public async whoamiWait(): Promise<number> {\n    const result = await this.readWait(MPU6050.commands.whoami, 1);\n    return result[0];\n  }\n\n  public async getAccelAdcWait(): Promise<Xyz> {\n    const raw = await this.readWait(MPU6050.commands.accel_x_h, 6);\n    return MPU6050.charArrayToXyz(raw, \"b\");\n  }\n\n  public async getGyroAdcWait(): Promise<Xyz> {\n    const raw = await this.readWait(MPU6050.commands.gyro_x_h, 6);\n    return MPU6050.charArrayToXyz(raw, \"b\");\n  }\n\n  public async getTempAdcWait(): Promise<number> {\n    const raw = await this.readWait(MPU6050.commands.temp_h, 2);\n    return MPU6050.charArrayToInt16(raw as [number, number], \"b\");\n  }\n\n  public async getAllAdcWait(): Promise<Inertia6> {\n    const raw = await this.readWait(MPU6050.commands.accel_x_h, 14);\n    return {\n      accelerometer: MPU6050.charArrayToXyz(raw.slice(0, 6), \"b\"),\n      gyroscope: MPU6050.charArrayToXyz(raw.slice(8, 14), \"b\"),\n      temperature: MPU6050.charArrayToInt16(raw.slice(6, 8) as [number, number], \"b\"),\n    };\n  }\n\n  public setAccelRange(accel_range: accelRange): void {\n    if (accel_range in MPU6050.commands.accel_fs_sel) {\n      this.write(MPU6050.commands.accel_config, MPU6050.commands.accel_fs_sel[accel_range]);\n      this.accel_so = accel_range;\n    } else {\n      throw new Error(`Invalid accel range. Valid values are: ${Object.keys(MPU6050.commands.accel_fs_sel).join()}`);\n    }\n  }\n\n  public setGyroRange(gyro_range: gyroRange): void {\n    if (gyro_range in MPU6050.commands.gyro_fs_sel) {\n      this.write(MPU6050.commands.gyro_config, MPU6050.commands.gyro_fs_sel[gyro_range]);\n      this.gyro_so = gyro_range;\n    } else {\n      throw new Error(`Invalid gyro range. Valid values are: ${Object.keys(MPU6050.commands.gyro_fs_sel).join()}`);\n    }\n  }\n\n  public setConfig(accelerometer_range: number, gyroscope_range: number, ADC_cycle?: any) {\n    // accel range set (0x00:2g, 0x08:4g, 0x10:8g, 0x18:16g)\n    switch (accelerometer_range) {\n      case 2:\n        this.setAccelRange(\"2g\");\n        break;\n      case 4:\n        this.setAccelRange(\"4g\");\n        break;\n      case 8:\n        this.setAccelRange(\"8g\");\n        break;\n      case 16:\n        this.setAccelRange(\"16g\");\n        break;\n      default:\n        throw new Error(\"accel_range variable 2,4,8,16 setting\");\n    }\n    // gyro range & LPF set (0x00:250, 0x08:500, 0x10:1000, 0x18:2000[deg/s])\n    switch (gyroscope_range) {\n      case 250:\n        this.setGyroRange(\"250dps\");\n        break;\n      case 500:\n        this.setGyroRange(\"500dps\");\n        break;\n      case 1000:\n        this.setGyroRange(\"1000dps\");\n        break;\n      case 2000:\n        this.setGyroRange(\"2000dps\");\n        break;\n      default:\n        throw new Error(\"accel_range variable 250,500,1000,2000 setting\");\n    }\n  }\n}\n"]}