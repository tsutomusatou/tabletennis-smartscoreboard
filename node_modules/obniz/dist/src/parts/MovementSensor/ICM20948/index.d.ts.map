{"version":3,"sources":["../src/parts/MovementSensor/ICM20948/index.ts"],"names":[],"mappings":"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","file":"index.d.ts","sourcesContent":["/**\n * @packageDocumentation\n * @module Parts.ICM20948\n */\n\nimport Obniz from \"../../../obniz\";\nimport ObnizPartsInterface, { ObnizPartsInfo } from \"../../../obniz/ObnizPartsInterface\";\nimport i2cParts, { I2cInfo, I2cPartsAbstractOptions } from \"../../i2cParts\";\nimport AK09916, { AK09916Options } from \"../AK09916/index\";\n\nexport interface ICM20948Options extends I2cPartsAbstractOptions {}\n\nexport default class ICM20948 extends i2cParts implements ObnizPartsInterface {\n  public static info(): ObnizPartsInfo {\n    return {\n      name: \"ICM20948\",\n    };\n  }\n\n  public g = 9.80665;\n\n  public i2cinfo: I2cInfo = {\n    address: 0x69,\n    clock: 100000,\n    voltage: \"3v\",\n    pull: \"3v\",\n  };\n\n  protected obniz!: Obniz;\n\n  private _ADDR = 0x69;\n  private _ak09916?: AK09916;\n\n  private _WHO_AM_I = 0x00;\n  private _GYRO_CONFIG = 0x01;\n  private _ACCEL_CONFIG = 0x14;\n  private _ACCEL_CONFIG2 = 0x15;\n  private _INT_PIN_CFG = 0x0f;\n  private _ACCEL_XOUT_H = 0x2d;\n  private _ACCEL_XOUT_L = 0x2e;\n  private _ACCEL_YOUT_H = 0x2f;\n  private _ACCEL_YOUT_L = 0x30;\n  private _ACCEL_ZOUT_H = 0x31;\n  private _ACCEL_ZOUT_L = 0x32;\n  private _GYRO_XOUT_H = 0x33;\n  private _GYRO_XOUT_L = 0x34;\n  private _GYRO_YOUT_H = 0x35;\n  private _GYRO_YOUT_L = 0x36;\n  private _GYRO_ZOUT_H = 0x37;\n  private _GYRO_ZOUT_L = 0x38;\n\n  // #_ACCEL_FS_MASK = const(0b00011000)\n  private _ACCEL_FS_SEL_2G = 0b00000000;\n  private _ACCEL_FS_SEL_4G = 0b00000010;\n  private _ACCEL_FS_SEL_8G = 0b00000100;\n  private _ACCEL_FS_SEL_16G = 0b00000110;\n\n  private _ACCEL_SO_2G = 16384; // 1 / 16384 ie. 0.061 mg / digit\n  private _ACCEL_SO_4G = 8192; // 1 / 8192 ie. 0.122 mg / digit\n  private _ACCEL_SO_8G = 4096; // 1 / 4096 ie. 0.244 mg / digit\n  private _ACCEL_SO_16G = 2048; // 1 / 2048 ie. 0.488 mg / digit\n\n  private _GYRO_FS_MASK = 0b00000110;\n  private _GYRO_FS_SEL_250DPS = 0b00110001;\n  private _GYRO_FS_SEL_500DPS = 0b00110011;\n  private _GYRO_FS_SEL_1000DPS = 0b00110101;\n  private _GYRO_FS_SEL_2000DPS = 0b00110111;\n\n  private _GYRO_SO_250DPS = 131;\n  private _GYRO_SO_500DPS = 62.5;\n  private _GYRO_SO_1000DPS = 32.8;\n  private _GYRO_SO_2000DPS = 16.4;\n\n  // # Used for enablind and disabling the i2c bypass access\n  private _I2C_BYPASS_MASK = 0b00000010;\n  private _I2C_BYPASS_EN = 0b00000010;\n  private _I2C_BYPASS_DIS = 0b00000000;\n\n  private _SF_G = 1; //    g\n  private _SF_MG = 1000; //    mg\n  private _SF_M_S2 = 9.80665; // 1 g = 9.80665 m/s2 ie. standard gravity\n  private _SF_DEG_S = 1; // deg / s\n  private _SF_RAD_S = 57.295779578552; // 1 rad / s is 57.295779578552 deg / s;\n\n  private _accel_sf: number;\n  private _accel_so: number;\n  private _gyro_sf: number;\n  private _gyro_so: number;\n\n  constructor() {\n    super();\n    this._accel_sf = this._SF_M_S2;\n    this._accel_so = this._ACCEL_SO_2G;\n    this._gyro_sf = this._SF_DEG_S;\n    this._gyro_so = this._GYRO_SO_250DPS;\n  }\n\n  public wired(obniz: Obniz): void {\n    super.wired(obniz);\n    this._accel_so = this._accelFs(this._ACCEL_FS_SEL_2G);\n    this._gyro_so = this._gyroFs(this._GYRO_FS_SEL_250DPS);\n  }\n\n  public async initWait() {\n    const data = await this.whoamiWait();\n    if (data !== 0xea) {\n      throw new Error(\"ICM20948 not found in I2C bus.\");\n    }\n\n    this.write(0x06, [0x01]); // wake;\n    this.write(0x0f, [0x02]); // passthrough;\n    this.write(0x03, [0x00]);\n\n    // this.write(12, 0x31, [0x00]);  // power down mode\n    // const buf3 = await this._studuinoI2C.readFromMem(12, 0x60, 3);\n\n    this._ak09916 = this.obniz.wired(\"AK09916\", { i2c: this.i2c });\n  }\n\n  public accelFs(value: string) {\n    if (value === \"2g\") {\n      this._accel_so = this._accelFs(this._ACCEL_FS_SEL_2G);\n    } else if (value === \"4g\") {\n      this._accel_so = this._accelFs(this._ACCEL_FS_SEL_4G);\n    } else if (value === \"8g\") {\n      this._accel_so = this._accelFs(this._ACCEL_FS_SEL_8G);\n    } else if (value === \"16g\") {\n      this._accel_so = this._accelFs(this._ACCEL_FS_SEL_16G);\n    } else {\n      throw new Error(\"must be '2g'/'4g'/'8g'/'16g'\");\n    }\n  }\n\n  public accelSf(value: string) {\n    if (value === \"g\") {\n      this._accel_sf = this._SF_G;\n    } else if (value === \"mg\") {\n      this._accel_sf = this._SF_MG;\n    } else if (value === \"ms2\") {\n      this._accel_sf = this._SF_M_S2;\n    } else {\n      throw new Error(\"must be 'g'/'mg'/'ms2'\");\n    }\n  }\n\n  public async accelerationWait(): Promise<[number, number, number]> {\n    /*\n    Acceleration measured by the sensor. By default will return a\n    3-tuple of X, Y, Z axis accelerationWait values in mG as integer.\n    */\n    const so = this._accel_so;\n    const sf = this._accel_sf;\n    const xyz: [number, number, number] = await this.readThreeInt16Wait(this._ACCEL_XOUT_H);\n    return xyz.map((e) => (e / so) * sf) as [number, number, number];\n  }\n\n  public async gyroWait(): Promise<[number, number, number]> {\n    // \"\"\"\n    // X, Y, Z radians per second as floats.\n    // \"\"\"\n    const so = this._gyro_so;\n    const sf = this._gyro_sf;\n    const xyz: [number, number, number] = await this.readThreeInt16Wait(this._GYRO_XOUT_H);\n    return xyz.map((e) => (e / so) * sf) as [number, number, number];\n  }\n\n  public async magneticWait(): Promise<[number, number, number]> {\n    return this._ak09916!.magnetic();\n  }\n\n  public async calibrateWait() {\n    return await this._ak09916!.calibrateWait();\n  }\n\n  public async whoamiWait(): Promise<number> {\n    // Value of the whoamiWait register. \"\"\"\n    const result = await this.readWait(this._WHO_AM_I, 1);\n    return result[0];\n  }\n\n  public gyroFs(value: string) {\n    if (value === \"250dps\") {\n      this._gyro_so = this._gyroFs(this._GYRO_FS_SEL_250DPS);\n    } else if (value === \"500dps\") {\n      this._gyro_so = this._gyroFs(this._GYRO_FS_SEL_500DPS);\n    } else if (value === \"1000dps\") {\n      this._gyro_so = this._gyroFs(this._GYRO_FS_SEL_1000DPS);\n    } else if (value === \"2000dps\") {\n      this._gyro_so = this._gyroFs(this._GYRO_FS_SEL_2000DPS);\n    } else {\n      throw new Error(\"must be '250dps'/'500dps'/'1000dps'/'2000dps'\");\n    }\n  }\n\n  public gyroSf(value: string) {\n    if (value === \"dps\") {\n      this._gyro_sf = this._SF_DEG_S;\n    } else if (value === \"rps\") {\n      this._gyro_sf = this._SF_RAD_S;\n    } else {\n      throw new Error(\"must be 'dps'/'rps'\");\n    }\n  }\n\n  private async _gyroDlpfWait(dlpfcfg: number = -1) {\n    this.write(0x7f, [0x20]);\n    // # get ICM20948 gyroWait configuration.\n    let char: number = (await this.readWait(this._GYRO_CONFIG, 1))[0];\n    char &= this._GYRO_FS_MASK; // clear DLDF bits\n\n    if (dlpfcfg === -1) {\n      char |= 0x00000000;\n    } else if (dlpfcfg === 0) {\n      char |= 0x00000001;\n    } else if (dlpfcfg === 1) {\n      char |= 0x00001001;\n    } else if (dlpfcfg === 2) {\n      char |= 0x00010001;\n    } else if (dlpfcfg === 3) {\n      char |= 0x00011001;\n    } else if (dlpfcfg === 4) {\n      char |= 0x00100001;\n    } else if (dlpfcfg === 5) {\n      char |= 0x00101001;\n    } else if (dlpfcfg === 6) {\n      char |= 0x00110001;\n    } else if (dlpfcfg === 7) {\n      char |= 0x00111001;\n    } else {\n      char |= 0x00000000;\n    }\n    this.write(this._GYRO_CONFIG, [char]);\n    this.write(0x7f, [0x00]);\n  }\n\n  private _accelFs(value: number): number {\n    this.write(0x7f, [0x20]);\n    this.write(this._ACCEL_CONFIG, [value]);\n    this.write(0x7f, [0x00]);\n\n    // # Return the sensitivity divider\n    if (this._ACCEL_FS_SEL_2G === value) {\n      return this._ACCEL_SO_2G;\n    } else if (this._ACCEL_FS_SEL_4G === value) {\n      return this._ACCEL_SO_4G;\n    } else if (this._ACCEL_FS_SEL_8G === value) {\n      return this._ACCEL_SO_8G;\n    } else if (this._ACCEL_FS_SEL_16G === value) {\n      return this._ACCEL_SO_16G;\n    }\n    return 0;\n  }\n\n  private _gyroFs(value: number): number {\n    this.write(0x7f, [0x20]);\n    this.write(this._GYRO_CONFIG, [value]);\n    this.write(0x7f, [0x00]);\n\n    // # Return the sensitivity divider\n    if (this._GYRO_FS_SEL_250DPS === value) {\n      return this._GYRO_SO_250DPS;\n    } else if (this._GYRO_FS_SEL_500DPS === value) {\n      return this._GYRO_SO_500DPS;\n    } else if (this._GYRO_FS_SEL_1000DPS === value) {\n      return this._GYRO_SO_1000DPS;\n    } else if (this._GYRO_FS_SEL_2000DPS === value) {\n      return this._GYRO_SO_2000DPS;\n    }\n\n    return 0;\n  }\n}\n"]}