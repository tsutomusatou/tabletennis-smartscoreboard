{"version":3,"sources":["../src/parts/Ble/cir415a/index.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAIH,OAAO,mBAAmB,MAAM,uDAAuD,CAAC;AACxF,OAAO,sBAAsB,EAAE,EAAE,iBAAiB,EAAE,MAAM,uCAAuC,CAAC;AAElG,MAAM,WAAW,cAAc;CAAG;AAElC,MAAM,CAAC,OAAO,OAAO,OAAQ,YAAW,sBAAsB;WAC9C,IAAI,IAAI,iBAAiB;WAMzB,QAAQ,CAAC,UAAU,EAAE,mBAAmB,GAAG,OAAO;IAIzD,QAAQ,EAAE,CAAC,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,IAAI,CAAC,GAAG,IAAI,CAAQ;IACnD,eAAe,EAAE,CAAC,MAAM,IAAI,CAAC,GAAG,IAAI,CAAQ;IAC5C,WAAW,EAAE,CAAC,CAAC,KAAK,EAAE,OAAO,KAAK,IAAI,CAAC,GAAG,IAAI,CAAQ;IACtD,WAAW,EAAE,mBAAmB,GAAG,IAAI,CAAQ;IAC/C,YAAY,CAAC,EAAE,CAAC,MAAM,EAAE,GAAG,KAAK,IAAI,CAAC;IAE5C,OAAO,CAAC,cAAc,CAAkB;IACxC,OAAO,CAAC,SAAS,CAiBf;IACF,OAAO,CAAC,UAAU,CAAgB;IAClC,OAAO,CAAC,kBAAkB,CAAgB;IAC1C,OAAO,CAAC,YAAY,CAAoE;IACxF,OAAO,CAAC,MAAM,CAIZ;IACF,OAAO,CAAC,QAAQ,CAAgB;IAChC,OAAO,CAAC,QAAQ,CAAwC;gBAE5C,UAAU,EAAE,mBAAmB,GAAG,IAAI;IAQrC,WAAW;IAuBX,cAAc;IAMd,KAAK,CAAC,IAAI,EAAE,MAAM,EAAE;IAa1B,YAAY,CAAC,GAAG,EAAE,MAAM,EAAE;IAOpB,kBAAkB,CAAC,MAAM,EAAE,OAAO;IAOlC,SAAS,CAAC,IAAI,EAAE,MAAM,EAAE;IAOrC,OAAO,CAAC,UAAU;IA6BlB,OAAO,CAAC,OAAO;IASf,OAAO,CAAC,OAAO;IAaf,OAAO,CAAC,cAAc;YAoDR,QAAQ;IA0BtB,OAAO,CAAC,UAAU;CAoBnB","file":"index.d.ts","sourcesContent":["/**\n * @packageDocumentation\n * @module Parts.cir415a\n */\n\nimport crypto from \"crypto\";\nimport BleRemoteCharacteristic from \"../../../obniz/libs/embeds/bleHci/bleRemoteCharacteristic\";\nimport BleRemotePeripheral from \"../../../obniz/libs/embeds/bleHci/bleRemotePeripheral\";\nimport ObnizPartsBleInterface, { ObnizPartsBleInfo } from \"../../../obniz/ObnizPartsBleInterface\";\n\nexport interface cir415aOptions {}\n\nexport default class cir415a implements ObnizPartsBleInterface {\n  public static info(): ObnizPartsBleInfo {\n    return {\n      name: \"cir415a\",\n    };\n  }\n\n  public static isDevice(peripheral: BleRemotePeripheral): boolean {\n    return peripheral.localName?.indexOf(\"ACR1255U-J1-\") === 0;\n  }\n\n  public onNotify: ((data: number[]) => void) | null = null;\n  public onAuthenticated: (() => void) | null = null;\n  public onCardTouch: ((state: boolean) => void) | null = null;\n  public _peripheral: BleRemotePeripheral | null = null;\n  public ondisconnect?: (reason: any) => void;\n\n  private _authenticated: boolean = false;\n  private masterKey: number[] = [\n    0x41,\n    0x43,\n    0x52,\n    0x31,\n    0x32,\n    0x35,\n    0x35,\n    0x55,\n    0x2d,\n    0x4a,\n    0x31,\n    0x20,\n    0x41,\n    0x75,\n    0x74,\n    0x68,\n  ];\n  private sessionKey: number[] = [];\n  private randomDeviceNumber: number[] = [];\n  private randomNumber: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n  private _uuids = {\n    service: \"3C4AFFF0-4783-3DE5-A983-D348718EF133\",\n    writeChar: \"3C4AFFF1-4783-3DE5-A983-D348718EF133\",\n    readChar: \"3C4AFFF2-4783-3DE5-A983-D348718EF133\",\n  };\n  private readData: number[] = [];\n  private readChar: BleRemoteCharacteristic | null = null;\n\n  constructor(peripheral: BleRemotePeripheral | null) {\n    if (peripheral && !cir415a.isDevice(peripheral)) {\n      throw new Error(\"peripheral is not cir415a\");\n    }\n    this._peripheral = peripheral;\n    this._authenticated = false;\n  }\n\n  public async connectWait() {\n    if (!this._peripheral) {\n      throw new Error(\"peripheral is not cir415a\");\n    }\n    if (!this._peripheral.connected) {\n      this._peripheral.ondisconnect = (reason: any) => {\n        if (typeof this.ondisconnect === \"function\") {\n          this.ondisconnect(reason);\n        }\n      };\n      await this._peripheral.connectWait();\n      this.randomDeviceNumber = [];\n      this.readData = [];\n    }\n    const service = this._peripheral.getService(this._uuids.service)!;\n    this.readChar = service.getCharacteristic(this._uuids.writeChar);\n    await service.getCharacteristic(this._uuids.readChar)!.registerNotifyWait(async (data: number[]) => {\n      this.readPacket(data);\n    });\n\n    await this.writeBle([0x6b, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x45, 0x00], null); // auth step.1\n  }\n\n  public async disconnectWait() {\n    if (this._peripheral && this._peripheral.connected) {\n      await this._peripheral.disconnectWait();\n    }\n  }\n\n  public async write(data: number[]) {\n    if (!this._authenticated) {\n      throw new Error(\"cir415a no authenticate\");\n    }\n    if (data.length % 16 !== 0) {\n      const l = 16 - (data.length % 16);\n      for (let i = 0; i < l; i++) {\n        data.push(0xff);\n      }\n    }\n    this.writeBle(data, this.sessionKey);\n  }\n\n  public setMasterKey(key: number[]) {\n    if (key.length !== 16) {\n      throw new Error(\"setMasterKey length error\");\n    }\n    this.masterKey = key;\n  }\n\n  public async setAutoPollingWait(enable: boolean) {\n    if (!this._authenticated) {\n      throw new Error(\"cir415a no authenticate\");\n    }\n    await this.write([0x6b, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x40, enable ? 0x01 : 0x00]);\n  }\n\n  public async writeADPU(data: number[]) {\n    if (!this._authenticated) {\n      throw new Error(\"cir415a no authenticate\");\n    }\n    await this.write([0x6f, (data.length & 0xff00) >> 8, data.length & 0x00ff, 0x00, 0x00, 0x00, 0x00].concat(data));\n  }\n\n  private readPacket(data: number[]) {\n    this.readData = this.readData.concat(data);\n    if (this.readData[0] !== 0x05) {\n      this.readData = [];\n    }\n    const dLength = ((this.readData[1] & 0xff) << 8) | (this.readData[2] & 0x00ff);\n\n    if (this.readData.length - 5 < dLength) {\n      // lack data length\n      return;\n    }\n    if (this.readData[dLength + 4] === 0x0a) {\n      // last packet check\n      data = this.readData.slice(0, dLength + 5);\n      this.parseBlePacket(data);\n      if (this.readData.length > dLength + 5) {\n        // more data\n        this.readData = this.readData.slice(dLength + 5);\n        this.readPacket([]);\n      } else {\n        // delete data\n        this.readData = [];\n      }\n    } else {\n      // console.log(\"error data\");\n      this.readData = [];\n    }\n  }\n\n  private encrypt(data: number[], key: number[]): number[] {\n    const c = crypto.createCipheriv(\"aes-128-cbc\", Buffer.from(key), new Uint8Array(16));\n    c.setAutoPadding(false);\n\n    let t = c.update(Buffer.from(data), undefined, \"hex\");\n    t += c.final(\"hex\");\n    return Array.from(Buffer.from(t, \"hex\"));\n  }\n\n  private decrypt(data: number[], key: number[]): number[] {\n    const dec = crypto.createDecipheriv(\"aes-128-cbc\", Buffer.from(key), new Uint8Array(16));\n    dec.setAutoPadding(false);\n    let t = dec.update(Buffer.from(data), \"binary\", \"binary\");\n    t += dec.final(\"binary\");\n    const d = Array.from(Buffer.from(t));\n    const list: number[] = [];\n    for (let i = 0; i < d.length; i++) {\n      list.push(d[i] >= 194 ? ((d[i] & 0b00000011) << 6) | (d[++i] & 0b00111111) : d[i]);\n    }\n    return list;\n  }\n\n  private parseBlePacket(data: number[]) {\n    switch (data[3]) {\n      case 0x83:\n        if (!this._authenticated) {\n          if (this.randomDeviceNumber.length <= 0) {\n            // auth step.2\n            let randomDevice: number[] = [];\n            for (let i = 15; i < data.length - 2; i++) {\n              randomDevice.push(data[i]);\n            }\n            this.randomDeviceNumber = randomDevice;\n            randomDevice = this.decrypt(randomDevice, this.masterKey);\n            this.sessionKey = randomDevice.slice(0, 8).concat(this.randomNumber.slice(0, 8));\n            randomDevice = this.decrypt(this.randomNumber.concat(randomDevice), this.masterKey);\n            let sendPacket = [0x6b, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x46, 0x00];\n            sendPacket = sendPacket.concat(randomDevice);\n            this.writeBle(sendPacket, null);\n            return;\n            // auth step.3\n          } else {\n            // auth step.4\n            let randomDevice: number[] = [];\n            for (let i = 15; i < data.length - 2; i++) {\n              randomDevice.push(data[i]);\n            }\n            randomDevice = this.decrypt(randomDevice, this.masterKey);\n            if (this.arrayMatch(this.randomNumber, randomDevice)) {\n              this._authenticated = true;\n              if (this.onAuthenticated) {\n                this.onAuthenticated();\n              }\n            }\n            return;\n          }\n        }\n        break;\n    }\n    const d = this.decrypt(data.slice(3, data.length - 2), this.sessionKey);\n    const dLen = (((d[1] & 0xff) << 8) | (d[2] & 0x00ff)) + 7; // command Data Form 7 length\n    const dt = d.slice(0, dLen);\n    switch (dt[0]) {\n      case 0x50:\n        if (this.onCardTouch) {\n          this.onCardTouch(dt[5] === 3);\n        }\n        break;\n    }\n    if (this.onNotify) {\n      this.onNotify(dt);\n    }\n  }\n\n  private async writeBle(data: number[], key: number[] | null) {\n    let packet = [0x05, (data.length & 0xff00) >> 8, data.length & 0x00ff];\n    let checksum = 0;\n    for (let i = 0; i < data.length; i++) {\n      if (i === 6) {\n        continue; // check sum\n      }\n      checksum = (checksum ^ data[i]) & 0xff;\n    }\n    data[6] = checksum;\n    if (key !== null) {\n      data = this.encrypt(data, key);\n    }\n    packet = packet.concat(data);\n    checksum = 0;\n    for (let i = 1; i < packet.length; i++) {\n      checksum = (checksum ^ packet[i]) & 0xff;\n    }\n    packet.push(checksum);\n    packet.push(0x0a);\n    for (let i = 0; i < packet.length / 20; i++) {\n      const d = packet.slice(i * 20, (i + 1) * 20);\n      await this.readChar!.writeWait(d);\n    }\n  }\n\n  private arrayMatch(array1: number[], array2: number[]): boolean {\n    if (array1.length === array2.length) {\n      for (let i = 0; i < array1.length; i++) {\n        if (array1[i] === array2[i]) {\n          break;\n        }\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  // private printHex(data: number[], tag: string) {\n  //   let s = \"\";\n  //   for (let i = 0; i < data.length; i++) {\n  //     s += \"0x\" + (\"0\" + data[i].toString(16)).slice(-2) + \", \";\n  //   }\n  //   console.log(`${tag} : ${s}`);\n  // }\n}\n"]}